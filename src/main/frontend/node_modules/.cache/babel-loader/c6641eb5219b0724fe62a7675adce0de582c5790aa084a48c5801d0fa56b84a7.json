{"ast":null,"code":"import _toConsumableArray from \"C:/Users/\\uC190\\uD55C\\uC2B9/Desktop/project-subway/src/main/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _omitBy from \"lodash/omitBy\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _isEqual from \"lodash/isEqual\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _orderBy from \"lodash/orderBy\";\nimport _property from \"lodash/property\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _uniq from \"lodash/uniq\";\n/* eslint-disable no-use-before-define */\nimport React from \"react\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\nimport * as Scale from \"./scale\";\nimport * as Immutable from \"./immutable\";\n\n// Private Functions\n\nfunction parseDatum(datum) {\n  var immutableDatumWhitelist = {\n    errorX: true,\n    errorY: true\n  };\n  return Immutable.isImmutable(datum) ? Immutable.shallowToJS(datum, immutableDatumWhitelist) : datum;\n}\nfunction getLength(data) {\n  return Immutable.isIterable(data) ? data.size : data.length;\n}\n\n// Returns generated data for a given axis based on domain and sample from props\nfunction generateDataArray(props, axis) {\n  var propsDomain = _isPlainObject(props.domain) ? props.domain[axis] : props.domain;\n  var domain = propsDomain || Scale.getBaseScale(props, axis).domain();\n  var samples = props.samples || 1;\n  var domainMax = Math.max.apply(Math, _toConsumableArray(domain));\n  var domainMin = Math.min.apply(Math, _toConsumableArray(domain));\n  var step = (domainMax - domainMin) / samples;\n  var values = Helpers.range(domainMin, domainMax, step);\n  return values[values.length - 1] === domainMax ? values : values.concat(domainMax);\n}\n\n// Returns sorted data. If no sort keys are provided, data is returned unaltered.\nfunction sortData(dataset, sortKey, sortOrder) {\n  if (sortOrder === void 0) {\n    sortOrder = \"ascending\";\n  }\n  if (!sortKey) {\n    return dataset;\n  }\n\n  // Ensures previous VictoryLine api for sortKey prop stays consistent\n  var formattedSortKey = sortKey;\n  if (sortKey === \"x\" || sortKey === \"y\") {\n    formattedSortKey = \"_\".concat(sortKey);\n  }\n  var order = sortOrder === \"ascending\" ? \"asc\" : \"desc\";\n  return _orderBy(dataset, formattedSortKey, order);\n}\n\n// This method will remove data points that break certain scales. (log scale only)\nfunction cleanData(dataset, props) {\n  var smallNumber = 1 / Number.MAX_SAFE_INTEGER;\n  var scaleType = {\n    x: Scale.getScaleType(props, \"x\"),\n    y: Scale.getScaleType(props, \"y\")\n  };\n  if (scaleType.x !== \"log\" && scaleType.y !== \"log\") {\n    return dataset;\n  }\n  var rules = function rules(datum, axis) {\n    return scaleType[axis] === \"log\" ? datum[\"_\".concat(axis)] !== 0 : true;\n  };\n  var sanitize = function sanitize(datum) {\n    var _x = rules(datum, \"x\") ? datum._x : smallNumber;\n    var _y = rules(datum, \"y\") ? datum._y : smallNumber;\n    var _y0 = rules(datum, \"y0\") ? datum._y0 : smallNumber;\n    return Object.assign({}, datum, {\n      _x: _x,\n      _y: _y,\n      _y0: _y0\n    });\n  };\n  return dataset.map(function (datum) {\n    if (rules(datum, \"x\") && rules(datum, \"y\") && rules(datum, \"y0\")) {\n      return datum;\n    }\n    return sanitize(datum);\n  });\n}\n\n// Returns a data accessor given an eventKey prop\nfunction getEventKey(key) {\n  // creates a data accessor function\n  // given a property key, path, array index, or null for identity.\n  if (Helpers.isFunction(key)) {\n    return key;\n  } else if (key === null || key === undefined) {\n    return function () {\n      return undefined;\n    };\n  }\n  // otherwise, assume it is an array index, property key or path (_.property handles all three)\n  return _property(key);\n}\n\n// Returns data with an eventKey prop added to each datum\nfunction addEventKeys(props, data) {\n  var hasEventKeyAccessor = !!props.eventKey;\n  var eventKeyAccessor = getEventKey(props.eventKey);\n  return data.map(function (datum, index) {\n    if (datum.eventKey !== undefined) {\n      return datum;\n    } else if (hasEventKeyAccessor) {\n      var eventKey = eventKeyAccessor(datum, index);\n      return eventKey !== undefined ? Object.assign({\n        eventKey: eventKey\n      }, datum) : datum;\n    }\n    return datum;\n  });\n}\n\n// Exported Functions\n\n// This method will remove data points that fall outside of the desired domain (non-continuous charts only)\nexport function formatDataFromDomain(dataset, domain, defaultBaseline) {\n  var exists = function exists(val) {\n    return val !== undefined;\n  };\n  var minDomainX = Collection.getMinValue(domain.x);\n  var maxDomainX = Collection.getMaxValue(domain.x);\n  var minDomainY = Collection.getMinValue(domain.y);\n  var maxDomainY = Collection.getMaxValue(domain.y);\n  var underMin = function underMin(min) {\n    return function (val) {\n      return exists(val) && val < min;\n    };\n  };\n  var overMax = function overMax(max) {\n    return function (val) {\n      return exists(val) && val > max;\n    };\n  };\n  var isUnderMinX = underMin(minDomainX);\n  var isUnderMinY = underMin(minDomainY);\n  var isOverMaxX = overMax(maxDomainX);\n  var isOverMaxY = overMax(maxDomainY);\n\n  // eslint-disable-next-line complexity\n  return dataset.map(function (datum) {\n    var _x = datum._x,\n      _y = datum._y,\n      _y0 = datum._y0,\n      _y1 = datum._y1;\n\n    // single x point less than min domain\n    if (isUnderMinX(_x) || isOverMaxX(_x)) _x = null;\n    var baseline = exists(_y0) ? _y0 : defaultBaseline;\n    var value = exists(_y1) ? _y1 : _y;\n    if (!exists(value)) return datum;\n\n    // value only and less than min domain or greater than max domain\n    if (!exists(baseline) && (isUnderMinY(value) || isOverMaxY(value))) _y = null;\n\n    // baseline and value are both less than min domain or both greater than max domain\n    if (isUnderMinY(baseline) && isUnderMinY(value) || isOverMaxY(baseline) && isOverMaxY(value)) _y = _y0 = _y1 = null;\n\n    // baseline and value with only baseline below min, set baseline to minDomainY\n    if (isUnderMinY(baseline) && !isUnderMinY(value)) _y0 = minDomainY;\n    // baseline and value with only baseline above max, set baseline to maxDomainY\n    if (isOverMaxY(baseline) && !isOverMaxY(value)) _y0 = maxDomainY;\n    return Object.assign({}, datum, _omitBy({\n      _x: _x,\n      _y: _y,\n      _y0: _y0,\n      _y1: _y1\n    }, _isUndefined));\n  });\n}\n\n/**\n * Returns an object mapping string data to numeric data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Object} an object mapping string data to numeric data\n */\nexport function createStringMap(props, axis) {\n  var stringsFromAxes = getStringsFromAxes(props, axis);\n  var stringsFromCategories = getStringsFromCategories(props, axis);\n  var stringsFromData = getStringsFromData(props, axis);\n  var allStrings = _uniq([].concat(_toConsumableArray(stringsFromAxes), _toConsumableArray(stringsFromCategories), _toConsumableArray(stringsFromData)));\n  return allStrings.length === 0 ? null : allStrings.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n}\n\n/**\n * Reduces the size of a data array, such that it is <= maxPoints.\n * @param {Array} data: an array of data; must be sorted\n * @param {Number} maxPoints: maximum number of data points to return\n * @param {Number} startingIndex: the index of the data[0] *in the entire dataset*; this function\n                   assumes `data` param is a subset of larger dataset that has been zoommed\n  * @returns {Array} an array of data, a subset of data param\n  */\nexport function downsample(data, maxPoints, startingIndex) {\n  if (startingIndex === void 0) {\n    startingIndex = 0;\n  }\n  // ensures that the downampling of data while zooming looks good.\n  var dataLength = getLength(data);\n  if (dataLength > maxPoints) {\n    // limit k to powers of 2, e.g. 64, 128, 256\n    // so that the same points will be chosen reliably, reducing flicker on zoom\n    var k = Math.pow(2, Math.ceil(Math.log2(dataLength / maxPoints)));\n    return data.filter(\n    // ensure modulo is always calculated from same reference: i + startingIndex\n    function (d, i) {\n      return (i + startingIndex) % k === 0;\n    });\n  }\n  return data;\n}\n\n/**\n * Returns formatted data. Data accessors are applied, and string values are replaced.\n * @param {Array} dataset: the original domain\n * @param {Object} props: the props object\n * @param {Array} expectedKeys: an array of expected data keys\n * @returns {Array} the formatted data\n */\nexport function formatData(dataset, props, expectedKeys) {\n  var isArrayOrIterable = Array.isArray(dataset) || Immutable.isIterable(dataset);\n  if (!isArrayOrIterable || getLength(dataset) < 1) {\n    return [];\n  }\n  var defaultKeys = [\"x\", \"y\", \"y0\"];\n  // TODO: We shouldn’t mutate the expectedKeys param here,\n  // but we need to figure out why changing it causes regressions in tests.\n  // eslint-disable-next-line no-param-reassign\n  expectedKeys = Array.isArray(expectedKeys) ? expectedKeys : defaultKeys;\n  var createAccessor = function createAccessor(name) {\n    return Helpers.createAccessor(props[name] !== undefined ? props[name] : name);\n  };\n  var accessor = expectedKeys.reduce(function (memo, type) {\n    memo[type] = createAccessor(type);\n    return memo;\n  }, {});\n  var preformattedData = _isEqual(expectedKeys, defaultKeys) && props.x === \"_x\" && props.y === \"_y\" && props.y0 === \"_y0\";\n  var stringMap;\n  if (preformattedData === false) {\n    // stringMap is not required if the data is preformatted\n    stringMap = {\n      x: expectedKeys.indexOf(\"x\") !== -1 ? createStringMap(props, \"x\") : undefined,\n      y: expectedKeys.indexOf(\"y\") !== -1 ? createStringMap(props, \"y\") : undefined,\n      y0: expectedKeys.indexOf(\"y0\") !== -1 ? createStringMap(props, \"y\") : undefined\n    };\n  }\n  var data = preformattedData ? dataset : dataset.reduce(function (dataArr, datum, index) {\n    // eslint-disable-line complexity\n    var parsedDatum = parseDatum(datum);\n    var fallbackValues = {\n      x: index,\n      y: parsedDatum\n    };\n    var processedValues = expectedKeys.reduce(function (memo, type) {\n      var processedValue = accessor[type](parsedDatum);\n      var value = processedValue !== undefined ? processedValue : fallbackValues[type];\n      if (value !== undefined) {\n        if (typeof value === \"string\" && stringMap[type]) {\n          memo[\"\".concat(type, \"Name\")] = value;\n          memo[\"_\".concat(type)] = stringMap[type][value];\n        } else {\n          memo[\"_\".concat(type)] = value;\n        }\n      }\n      return memo;\n    }, {});\n    var formattedDatum = Object.assign({}, processedValues, parsedDatum);\n    if (!_isEmpty(formattedDatum)) {\n      dataArr.push(formattedDatum);\n    }\n    return dataArr;\n  }, []);\n  var sortedData = sortData(data, props.sortKey, props.sortOrder);\n  var cleanedData = cleanData(sortedData, props);\n  return addEventKeys(props, cleanedData);\n}\n\n/**\n * Returns generated x and y data based on domain and sample from props\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\nexport function generateData(props) {\n  var xValues = generateDataArray(props, \"x\");\n  var yValues = generateDataArray(props, \"y\");\n  var values = xValues.map(function (x, i) {\n    return {\n      x: x,\n      y: yValues[i]\n    };\n  });\n  return values;\n}\n\n/**\n * Returns an array of categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of categories\n */\nexport function getCategories(props, axis) {\n  return props.categories && !Array.isArray(props.categories) ? props.categories[axis] : props.categories;\n}\n\n/**\n * Returns an array of formatted data\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\nexport function getData(props) {\n  return props.data ? formatData(props.data, props) : formatData(generateData(props), props);\n}\n\n/**\n * Returns an array of strings from axis tickValues for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\nexport function getStringsFromAxes(props, axis) {\n  var tickValues = props.tickValues,\n    tickFormat = props.tickFormat;\n  var tickValueArray;\n  if (!tickValues || !Array.isArray(tickValues) && !tickValues[axis]) {\n    tickValueArray = tickFormat && Array.isArray(tickFormat) ? tickFormat : [];\n  } else {\n    tickValueArray = tickValues[axis] || tickValues;\n  }\n  return tickValueArray.filter(function (val) {\n    return typeof val === \"string\";\n  });\n}\n\n/**\n * Returns an array of strings from categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\nexport function getStringsFromCategories(props, axis) {\n  if (!props.categories) {\n    return [];\n  }\n  var categories = getCategories(props, axis);\n  var categoryStrings = categories && categories.filter(function (val) {\n    return typeof val === \"string\";\n  });\n  return categoryStrings ? Collection.removeUndefined(categoryStrings) : [];\n}\n\n/**\n * Returns an array of strings from data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\nexport function getStringsFromData(props, axis) {\n  var isArrayOrIterable = Array.isArray(props.data) || Immutable.isIterable(props.data);\n  if (!isArrayOrIterable) {\n    return [];\n  }\n  var key = props[axis] === undefined ? axis : props[axis];\n  var accessor = Helpers.createAccessor(key);\n\n  // support immutable data\n  var data = props.data.reduce(function (memo, d) {\n    memo.push(parseDatum(d));\n    return memo;\n  }, []);\n  var sortedData = sortData(data, props.sortKey, props.sortOrder);\n  var dataStrings = sortedData.reduce(function (dataArr, datum) {\n    var parsedDatum = parseDatum(datum);\n    dataArr.push(accessor(parsedDatum));\n    return dataArr;\n  }, []).filter(function (datum) {\n    return typeof datum === \"string\";\n  });\n\n  // return a unique set of strings\n  return dataStrings.reduce(function (prev, curr) {\n    if (curr !== undefined && curr !== null && prev.indexOf(curr) === -1) {\n      prev.push(curr);\n    }\n    return prev;\n  }, []);\n}\n\n/**\n * Checks whether a given component can be used to calculate data\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\nexport function isDataComponent(component) {\n  var getRole = function getRole(child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n  var role = getRole(component);\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n  var whitelist = [\"area\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"histogram\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return whitelist.includes(role);\n}","map":{"version":3,"names":["_omitBy","_isUndefined","_isEqual","_isEmpty","_orderBy","_property","_isPlainObject","_uniq","React","Helpers","Collection","Scale","Immutable","parseDatum","datum","immutableDatumWhitelist","errorX","errorY","isImmutable","shallowToJS","getLength","data","isIterable","size","length","generateDataArray","props","axis","propsDomain","domain","getBaseScale","samples","domainMax","Math","max","apply","_toConsumableArray","domainMin","min","step","values","range","concat","sortData","dataset","sortKey","sortOrder","formattedSortKey","order","cleanData","smallNumber","Number","MAX_SAFE_INTEGER","scaleType","x","getScaleType","y","rules","sanitize","_x","_y","_y0","Object","assign","map","getEventKey","key","isFunction","undefined","addEventKeys","hasEventKeyAccessor","eventKey","eventKeyAccessor","index","formatDataFromDomain","defaultBaseline","exists","val","minDomainX","getMinValue","maxDomainX","getMaxValue","minDomainY","maxDomainY","underMin","overMax","isUnderMinX","isUnderMinY","isOverMaxX","isOverMaxY","_y1","baseline","value","createStringMap","stringsFromAxes","getStringsFromAxes","stringsFromCategories","getStringsFromCategories","stringsFromData","getStringsFromData","allStrings","reduce","memo","string","downsample","maxPoints","startingIndex","dataLength","k","pow","ceil","log2","filter","d","i","formatData","expectedKeys","isArrayOrIterable","Array","isArray","defaultKeys","createAccessor","name","accessor","type","preformattedData","y0","stringMap","indexOf","dataArr","parsedDatum","fallbackValues","processedValues","processedValue","formattedDatum","push","sortedData","cleanedData","generateData","xValues","yValues","getCategories","categories","getData","tickValues","tickFormat","tickValueArray","categoryStrings","removeUndefined","dataStrings","prev","curr","isDataComponent","component","getRole","child","role","children","Children","toArray","whitelist","includes"],"sources":["C:/Users/손한승/Desktop/project-subway/src/main/frontend/node_modules/victory-core/es/victory-util/data.js"],"sourcesContent":["import _omitBy from \"lodash/omitBy\";\nimport _isUndefined from \"lodash/isUndefined\";\nimport _isEqual from \"lodash/isEqual\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _orderBy from \"lodash/orderBy\";\nimport _property from \"lodash/property\";\nimport _isPlainObject from \"lodash/isPlainObject\";\nimport _uniq from \"lodash/uniq\";\n/* eslint-disable no-use-before-define */\nimport React from \"react\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\nimport * as Scale from \"./scale\";\nimport * as Immutable from \"./immutable\";\n\n// Private Functions\n\nfunction parseDatum(datum) {\n  const immutableDatumWhitelist = {\n    errorX: true,\n    errorY: true\n  };\n  return Immutable.isImmutable(datum) ? Immutable.shallowToJS(datum, immutableDatumWhitelist) : datum;\n}\nfunction getLength(data) {\n  return Immutable.isIterable(data) ? data.size : data.length;\n}\n\n// Returns generated data for a given axis based on domain and sample from props\nfunction generateDataArray(props, axis) {\n  const propsDomain = _isPlainObject(props.domain) ? props.domain[axis] : props.domain;\n  const domain = propsDomain || Scale.getBaseScale(props, axis).domain();\n  const samples = props.samples || 1;\n  const domainMax = Math.max(...domain);\n  const domainMin = Math.min(...domain);\n  const step = (domainMax - domainMin) / samples;\n  const values = Helpers.range(domainMin, domainMax, step);\n  return values[values.length - 1] === domainMax ? values : values.concat(domainMax);\n}\n\n// Returns sorted data. If no sort keys are provided, data is returned unaltered.\nfunction sortData(dataset, sortKey, sortOrder) {\n  if (sortOrder === void 0) {\n    sortOrder = \"ascending\";\n  }\n  if (!sortKey) {\n    return dataset;\n  }\n\n  // Ensures previous VictoryLine api for sortKey prop stays consistent\n  let formattedSortKey = sortKey;\n  if (sortKey === \"x\" || sortKey === \"y\") {\n    formattedSortKey = `_${sortKey}`;\n  }\n  const order = sortOrder === \"ascending\" ? \"asc\" : \"desc\";\n  return _orderBy(dataset, formattedSortKey, order);\n}\n\n// This method will remove data points that break certain scales. (log scale only)\nfunction cleanData(dataset, props) {\n  const smallNumber = 1 / Number.MAX_SAFE_INTEGER;\n  const scaleType = {\n    x: Scale.getScaleType(props, \"x\"),\n    y: Scale.getScaleType(props, \"y\")\n  };\n  if (scaleType.x !== \"log\" && scaleType.y !== \"log\") {\n    return dataset;\n  }\n  const rules = (datum, axis) => {\n    return scaleType[axis] === \"log\" ? datum[`_${axis}`] !== 0 : true;\n  };\n  const sanitize = datum => {\n    const _x = rules(datum, \"x\") ? datum._x : smallNumber;\n    const _y = rules(datum, \"y\") ? datum._y : smallNumber;\n    const _y0 = rules(datum, \"y0\") ? datum._y0 : smallNumber;\n    return Object.assign({}, datum, {\n      _x,\n      _y,\n      _y0\n    });\n  };\n  return dataset.map(datum => {\n    if (rules(datum, \"x\") && rules(datum, \"y\") && rules(datum, \"y0\")) {\n      return datum;\n    }\n    return sanitize(datum);\n  });\n}\n\n// Returns a data accessor given an eventKey prop\nfunction getEventKey(key) {\n  // creates a data accessor function\n  // given a property key, path, array index, or null for identity.\n  if (Helpers.isFunction(key)) {\n    return key;\n  } else if (key === null || key === undefined) {\n    return () => undefined;\n  }\n  // otherwise, assume it is an array index, property key or path (_.property handles all three)\n  return _property(key);\n}\n\n// Returns data with an eventKey prop added to each datum\nfunction addEventKeys(props, data) {\n  const hasEventKeyAccessor = !!props.eventKey;\n  const eventKeyAccessor = getEventKey(props.eventKey);\n  return data.map((datum, index) => {\n    if (datum.eventKey !== undefined) {\n      return datum;\n    } else if (hasEventKeyAccessor) {\n      const eventKey = eventKeyAccessor(datum, index);\n      return eventKey !== undefined ? Object.assign({\n        eventKey\n      }, datum) : datum;\n    }\n    return datum;\n  });\n}\n\n// Exported Functions\n\n// This method will remove data points that fall outside of the desired domain (non-continuous charts only)\nexport function formatDataFromDomain(dataset, domain, defaultBaseline) {\n  const exists = val => val !== undefined;\n  const minDomainX = Collection.getMinValue(domain.x);\n  const maxDomainX = Collection.getMaxValue(domain.x);\n  const minDomainY = Collection.getMinValue(domain.y);\n  const maxDomainY = Collection.getMaxValue(domain.y);\n  const underMin = min => val => exists(val) && val < min;\n  const overMax = max => val => exists(val) && val > max;\n  const isUnderMinX = underMin(minDomainX);\n  const isUnderMinY = underMin(minDomainY);\n  const isOverMaxX = overMax(maxDomainX);\n  const isOverMaxY = overMax(maxDomainY);\n\n  // eslint-disable-next-line complexity\n  return dataset.map(datum => {\n    let {\n      _x,\n      _y,\n      _y0,\n      _y1\n    } = datum;\n\n    // single x point less than min domain\n    if (isUnderMinX(_x) || isOverMaxX(_x)) _x = null;\n    const baseline = exists(_y0) ? _y0 : defaultBaseline;\n    const value = exists(_y1) ? _y1 : _y;\n    if (!exists(value)) return datum;\n\n    // value only and less than min domain or greater than max domain\n    if (!exists(baseline) && (isUnderMinY(value) || isOverMaxY(value))) _y = null;\n\n    // baseline and value are both less than min domain or both greater than max domain\n    if (isUnderMinY(baseline) && isUnderMinY(value) || isOverMaxY(baseline) && isOverMaxY(value)) _y = _y0 = _y1 = null;\n\n    // baseline and value with only baseline below min, set baseline to minDomainY\n    if (isUnderMinY(baseline) && !isUnderMinY(value)) _y0 = minDomainY;\n    // baseline and value with only baseline above max, set baseline to maxDomainY\n    if (isOverMaxY(baseline) && !isOverMaxY(value)) _y0 = maxDomainY;\n    return Object.assign({}, datum, _omitBy({\n      _x,\n      _y,\n      _y0,\n      _y1\n    }, _isUndefined));\n  });\n}\n\n/**\n * Returns an object mapping string data to numeric data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Object} an object mapping string data to numeric data\n */\nexport function createStringMap(props, axis) {\n  const stringsFromAxes = getStringsFromAxes(props, axis);\n  const stringsFromCategories = getStringsFromCategories(props, axis);\n  const stringsFromData = getStringsFromData(props, axis);\n  const allStrings = _uniq([...stringsFromAxes, ...stringsFromCategories, ...stringsFromData]);\n  return allStrings.length === 0 ? null : allStrings.reduce((memo, string, index) => {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n}\n\n/**\n * Reduces the size of a data array, such that it is <= maxPoints.\n * @param {Array} data: an array of data; must be sorted\n * @param {Number} maxPoints: maximum number of data points to return\n * @param {Number} startingIndex: the index of the data[0] *in the entire dataset*; this function\n                   assumes `data` param is a subset of larger dataset that has been zoommed\n  * @returns {Array} an array of data, a subset of data param\n  */\nexport function downsample(data, maxPoints, startingIndex) {\n  if (startingIndex === void 0) {\n    startingIndex = 0;\n  }\n  // ensures that the downampling of data while zooming looks good.\n  const dataLength = getLength(data);\n  if (dataLength > maxPoints) {\n    // limit k to powers of 2, e.g. 64, 128, 256\n    // so that the same points will be chosen reliably, reducing flicker on zoom\n    const k = Math.pow(2, Math.ceil(Math.log2(dataLength / maxPoints)));\n    return data.filter(\n    // ensure modulo is always calculated from same reference: i + startingIndex\n    (d, i) => (i + startingIndex) % k === 0);\n  }\n  return data;\n}\n\n/**\n * Returns formatted data. Data accessors are applied, and string values are replaced.\n * @param {Array} dataset: the original domain\n * @param {Object} props: the props object\n * @param {Array} expectedKeys: an array of expected data keys\n * @returns {Array} the formatted data\n */\nexport function formatData(dataset, props, expectedKeys) {\n  const isArrayOrIterable = Array.isArray(dataset) || Immutable.isIterable(dataset);\n  if (!isArrayOrIterable || getLength(dataset) < 1) {\n    return [];\n  }\n  const defaultKeys = [\"x\", \"y\", \"y0\"];\n  // TODO: We shouldn’t mutate the expectedKeys param here,\n  // but we need to figure out why changing it causes regressions in tests.\n  // eslint-disable-next-line no-param-reassign\n  expectedKeys = Array.isArray(expectedKeys) ? expectedKeys : defaultKeys;\n  const createAccessor = name => {\n    return Helpers.createAccessor(props[name] !== undefined ? props[name] : name);\n  };\n  const accessor = expectedKeys.reduce((memo, type) => {\n    memo[type] = createAccessor(type);\n    return memo;\n  }, {});\n  const preformattedData = _isEqual(expectedKeys, defaultKeys) && props.x === \"_x\" && props.y === \"_y\" && props.y0 === \"_y0\";\n  let stringMap;\n  if (preformattedData === false) {\n    // stringMap is not required if the data is preformatted\n    stringMap = {\n      x: expectedKeys.indexOf(\"x\") !== -1 ? createStringMap(props, \"x\") : undefined,\n      y: expectedKeys.indexOf(\"y\") !== -1 ? createStringMap(props, \"y\") : undefined,\n      y0: expectedKeys.indexOf(\"y0\") !== -1 ? createStringMap(props, \"y\") : undefined\n    };\n  }\n  const data = preformattedData ? dataset : dataset.reduce((dataArr, datum, index) => {\n    // eslint-disable-line complexity\n    const parsedDatum = parseDatum(datum);\n    const fallbackValues = {\n      x: index,\n      y: parsedDatum\n    };\n    const processedValues = expectedKeys.reduce((memo, type) => {\n      const processedValue = accessor[type](parsedDatum);\n      const value = processedValue !== undefined ? processedValue : fallbackValues[type];\n      if (value !== undefined) {\n        if (typeof value === \"string\" && stringMap[type]) {\n          memo[`${type}Name`] = value;\n          memo[`_${type}`] = stringMap[type][value];\n        } else {\n          memo[`_${type}`] = value;\n        }\n      }\n      return memo;\n    }, {});\n    const formattedDatum = Object.assign({}, processedValues, parsedDatum);\n    if (!_isEmpty(formattedDatum)) {\n      dataArr.push(formattedDatum);\n    }\n    return dataArr;\n  }, []);\n  const sortedData = sortData(data, props.sortKey, props.sortOrder);\n  const cleanedData = cleanData(sortedData, props);\n  return addEventKeys(props, cleanedData);\n}\n\n/**\n * Returns generated x and y data based on domain and sample from props\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\nexport function generateData(props) {\n  const xValues = generateDataArray(props, \"x\");\n  const yValues = generateDataArray(props, \"y\");\n  const values = xValues.map((x, i) => {\n    return {\n      x,\n      y: yValues[i]\n    };\n  });\n  return values;\n}\n\n/**\n * Returns an array of categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of categories\n */\nexport function getCategories(props, axis) {\n  return props.categories && !Array.isArray(props.categories) ? props.categories[axis] : props.categories;\n}\n\n/**\n * Returns an array of formatted data\n * @param {Object} props: the props object\n * @returns {Array} an array of data\n */\nexport function getData(props) {\n  return props.data ? formatData(props.data, props) : formatData(generateData(props), props);\n}\n\n/**\n * Returns an array of strings from axis tickValues for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\nexport function getStringsFromAxes(props, axis) {\n  const {\n    tickValues,\n    tickFormat\n  } = props;\n  let tickValueArray;\n  if (!tickValues || !Array.isArray(tickValues) && !tickValues[axis]) {\n    tickValueArray = tickFormat && Array.isArray(tickFormat) ? tickFormat : [];\n  } else {\n    tickValueArray = tickValues[axis] || tickValues;\n  }\n  return tickValueArray.filter(val => typeof val === \"string\");\n}\n\n/**\n * Returns an array of strings from categories for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\nexport function getStringsFromCategories(props, axis) {\n  if (!props.categories) {\n    return [];\n  }\n  const categories = getCategories(props, axis);\n  const categoryStrings = categories && categories.filter(val => typeof val === \"string\");\n  return categoryStrings ? Collection.removeUndefined(categoryStrings) : [];\n}\n\n/**\n * Returns an array of strings from data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} an array of strings\n */\nexport function getStringsFromData(props, axis) {\n  const isArrayOrIterable = Array.isArray(props.data) || Immutable.isIterable(props.data);\n  if (!isArrayOrIterable) {\n    return [];\n  }\n  const key = props[axis] === undefined ? axis : props[axis];\n  const accessor = Helpers.createAccessor(key);\n\n  // support immutable data\n  const data = props.data.reduce((memo, d) => {\n    memo.push(parseDatum(d));\n    return memo;\n  }, []);\n  const sortedData = sortData(data, props.sortKey, props.sortOrder);\n  const dataStrings = sortedData.reduce((dataArr, datum) => {\n    const parsedDatum = parseDatum(datum);\n    dataArr.push(accessor(parsedDatum));\n    return dataArr;\n  }, []).filter(datum => typeof datum === \"string\");\n\n  // return a unique set of strings\n  return dataStrings.reduce((prev, curr) => {\n    if (curr !== undefined && curr !== null && prev.indexOf(curr) === -1) {\n      prev.push(curr);\n    }\n    return prev;\n  }, []);\n}\n\n/**\n * Checks whether a given component can be used to calculate data\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\nexport function isDataComponent(component) {\n  const getRole = child => {\n    return child && child.type ? child.type.role : \"\";\n  };\n  let role = getRole(component);\n  if (role === \"portal\") {\n    const children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n  const whitelist = [\"area\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"histogram\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return whitelist.includes(role);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
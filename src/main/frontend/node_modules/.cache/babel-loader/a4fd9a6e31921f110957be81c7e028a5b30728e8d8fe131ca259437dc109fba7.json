{"ast":null,"code":"import _toConsumableArray from \"C:/Users/\\uC190\\uD55C\\uC2B9/Desktop/project-subway/src/main/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _isDate from \"lodash/isDate\";\nimport _sortedUniq from \"lodash/sortedUniq\";\nimport _isPlainObject from \"lodash/isPlainObject\";\n/* eslint-disable no-use-before-define */\nimport React from \"react\";\nimport * as Data from \"./data\";\nimport * as Scale from \"./scale\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\n\n// Private Methods\n\nfunction cleanDomain(domain, props, axis) {\n  var scaleType = Scale.getScaleType(props, axis);\n  if (scaleType !== \"log\") {\n    return domain;\n  }\n  var rules = function rules(dom) {\n    var almostZero = dom[0] < 0 || dom[1] < 0 ? -1 / Number.MAX_SAFE_INTEGER : 1 / Number.MAX_SAFE_INTEGER;\n    var domainOne = dom[0] === 0 ? almostZero : dom[0];\n    var domainTwo = dom[1] === 0 ? almostZero : dom[1];\n    return [domainOne, domainTwo];\n  };\n  return rules(domain);\n}\nfunction getDomainPadding(props, axis) {\n  var formatPadding = function formatPadding(padding) {\n    return Array.isArray(padding) ? {\n      left: padding[0],\n      right: padding[1]\n    } : {\n      left: padding,\n      right: padding\n    };\n  };\n  return _isPlainObject(props.domainPadding) ? formatPadding(props.domainPadding[axis]) : formatPadding(props.domainPadding);\n}\nfunction getFlatData(dataset, axis) {\n  var axisKey = \"_\".concat(axis);\n  return dataset.flat().map(function (datum) {\n    return datum[axisKey] && datum[axisKey][1] !== undefined ? datum[axisKey][1] : datum[axisKey];\n  });\n}\nfunction getExtremeFromData(dataset, axis, type) {\n  if (type === void 0) {\n    type = \"min\";\n  }\n  var getExtreme = function getExtreme(arr) {\n    return type === \"max\" ? Math.max.apply(Math, _toConsumableArray(arr)) : Math.min.apply(Math, _toConsumableArray(arr));\n  };\n  var initialValue = type === \"max\" ? -Infinity : Infinity;\n  var containsDate = false;\n  var result = dataset.flat().reduce(function (memo, datum) {\n    var current0 = datum[\"_\".concat(axis, \"0\")] !== undefined ? datum[\"_\".concat(axis, \"0\")] : datum[\"_\".concat(axis)];\n    var current1 = datum[\"_\".concat(axis, \"1\")] !== undefined ? datum[\"_\".concat(axis, \"1\")] : datum[\"_\".concat(axis)];\n    var current = getExtreme([current0, current1]);\n    containsDate = containsDate || current0 instanceof Date || current1 instanceof Date;\n    return getExtreme([memo, current]);\n  }, initialValue);\n  return containsDate ? new Date(result) : result;\n}\n\n// eslint-disable-next-line max-statements\nfunction padDomain(domain, props, axis) {\n  if (!props.domainPadding) {\n    return domain;\n  }\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var padding = getDomainPadding(props, axis);\n  if (!padding.left && !padding.right) {\n    return domain;\n  }\n  var min = Collection.getMinValue(domain);\n  var max = Collection.getMaxValue(domain);\n  var currentAxis = Helpers.getCurrentAxis(axis, props.horizontal);\n  var range = Helpers.getRange(props, currentAxis);\n  var rangeExtent = Math.abs(range[0] - range[1]);\n  var paddedRangeExtent = Math.max(rangeExtent - padding.left - padding.right, 1);\n  var paddedDomainExtent = Math.abs(max.valueOf() - min.valueOf()) / paddedRangeExtent * rangeExtent;\n  var simplePadding = {\n    left: paddedDomainExtent * padding.left / rangeExtent,\n    right: paddedDomainExtent * padding.right / rangeExtent\n  };\n  var paddedDomain = {\n    min: min.valueOf() - simplePadding.left,\n    max: max.valueOf() + simplePadding.right\n  };\n  var singleQuadrantDomainPadding = _isPlainObject(props.singleQuadrantDomainPadding) ? props.singleQuadrantDomainPadding[axis] : props.singleQuadrantDomainPadding;\n  var addsQuadrants = min >= 0 && paddedDomain.min <= 0 || max <= 0 && paddedDomain.max >= 0;\n  var adjust = function adjust(val, type) {\n    var coerce = type === \"min\" && min >= 0 && val <= 0 || type === \"max\" && max <= 0 && val >= 0;\n    return coerce ? 0 : val;\n  };\n  if (addsQuadrants && singleQuadrantDomainPadding !== false) {\n    // Naive initial padding calculation\n    var initialPadding = {\n      // @ts-expect-error `max/min` might be dates\n      left: Math.abs(max - min) * padding.left / rangeExtent,\n      // @ts-expect-error `max/min` might be dates\n      right: Math.abs(max - min) * padding.right / rangeExtent\n    };\n\n    // Adjust the domain by the initial padding\n    var adjustedDomain = {\n      min: adjust(min.valueOf() - initialPadding.left, \"min\"),\n      max: adjust(max.valueOf() + initialPadding.right, \"max\")\n    };\n\n    // re-calculate padding, taking the adjusted domain into account\n    var finalPadding = {\n      left: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.left / rangeExtent,\n      right: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.right / rangeExtent\n    };\n\n    // Adjust the domain by the final padding\n    paddedDomain = {\n      min: adjust(min.valueOf() - finalPadding.left, \"min\"),\n      max: adjust(max.valueOf() + finalPadding.right, \"max\")\n    };\n  }\n\n  // default to minDomain / maxDomain if they exist\n  var finalDomain = {\n    min: minDomain !== undefined ? minDomain : paddedDomain.min,\n    max: maxDomain !== undefined ? maxDomain : paddedDomain.max\n  };\n  return min instanceof Date || max instanceof Date ? getDomainFromMinMax(new Date(finalDomain.min), new Date(finalDomain.max)) : getDomainFromMinMax(finalDomain.min, finalDomain.max);\n}\n\n// Public Methods\n\n/**\n * Returns a getDomain function\n * @param {Function} getDomainFromDataFunction: a function that takes props and axis and\n * returns a domain based on data\n * @param {Function} formatDomainFunction: a function that takes domain, props, and axis and\n * returns a formatted domain\n * @returns {Function} a function that takes props and axis and returns a formatted domain\n */\nexport function createDomainFunction(getDomainFromDataFunction, formatDomainFunction) {\n  var getDomainFromDataFn = Helpers.isFunction(getDomainFromDataFunction) ? getDomainFromDataFunction : getDomainFromData;\n  var formatDomainFn = Helpers.isFunction(formatDomainFunction) ? formatDomainFunction : formatDomain;\n  return function (props, axis) {\n    var propsDomain = getDomainFromProps(props, axis);\n    if (propsDomain) {\n      return formatDomainFn(propsDomain, props, axis);\n    }\n    var categories = Data.getCategories(props, axis);\n    var domain = categories ? getDomainFromCategories(props, axis, categories) : getDomainFromDataFn(props, axis);\n    return domain ? formatDomainFn(domain, props, axis) : undefined;\n  };\n}\n\n/**\n * Returns a formatted domain.\n * @param {Array} domain: a domain in the form of a two element array\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} a domain in the form of a two element array\n */\nexport function formatDomain(domain, props, axis) {\n  return cleanDomain(padDomain(domain, props, axis), props, axis);\n}\n\n/**\n * Returns a domain for a given axis based on props, category, or data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\nexport function getDomain(props, axis) {\n  return createDomainFunction()(props, axis);\n}\n\n/**\n * Returns a domain based on categories if they exist\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} categories: an array of categories corresponding to a given axis\n * @returns {Array|undefined} returns a domain from categories or undefined\n */\nexport function getDomainFromCategories(props, axis, categories) {\n  var categoriesArray = categories || Data.getCategories(props, axis);\n  var polar = props.polar,\n    _props$startAngle = props.startAngle,\n    startAngle = _props$startAngle === void 0 ? 0 : _props$startAngle,\n    _props$endAngle = props.endAngle,\n    endAngle = _props$endAngle === void 0 ? 360 : _props$endAngle;\n  if (!categoriesArray) {\n    return undefined;\n  }\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  var stringArray = Collection.containsStrings(categoriesArray) ? Data.getStringsFromCategories(props, axis) : [];\n  var stringMap = stringArray.length === 0 ? null : stringArray.reduce(function (memo, string, index) {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n  var categoryValues = stringMap ? categoriesArray.map(function (value) {\n    return stringMap[value];\n  }) : categoriesArray;\n  var min = minDomain !== undefined ? minDomain : Collection.getMinValue(categoryValues);\n  var max = maxDomain !== undefined ? maxDomain : Collection.getMaxValue(categoryValues);\n  var categoryDomain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(categoryDomain, categoryValues) : categoryDomain;\n}\n\n/**\n * Returns a domain from a dataset for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} dataset: an array of data\n * @returns {Array} the domain based on data\n */\nexport function getDomainFromData(props, axis, dataset) {\n  var datasetArray = dataset || Data.getData(props);\n  var polar = props.polar,\n    _props$startAngle2 = props.startAngle,\n    startAngle = _props$startAngle2 === void 0 ? 0 : _props$startAngle2,\n    _props$endAngle2 = props.endAngle,\n    endAngle = _props$endAngle2 === void 0 ? 360 : _props$endAngle2;\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  if (datasetArray.length < 1) {\n    return minDomain !== undefined && maxDomain !== undefined ? getDomainFromMinMax(minDomain, maxDomain) : undefined;\n  }\n  var min = minDomain !== undefined ? minDomain : getExtremeFromData(datasetArray, axis, \"min\");\n  var max = maxDomain !== undefined ? maxDomain : getExtremeFromData(datasetArray, axis, \"max\");\n  var domain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(domain, getFlatData(datasetArray, axis)) : domain;\n}\n\n/**\n * Returns a domain in the form of a two element array given a min and max value.\n * @param {Number|Date} min: the props object\n * @param {Number|Date} max: the current axis\n * @returns {Array} the minDomain based on props\n */\nexport function getDomainFromMinMax(min, max) {\n  var getSinglePointDomain = function getSinglePointDomain(val) {\n    // d3-scale does not properly resolve very small differences.\n    var verySmallNumber =\n    // eslint-disable-next-line no-magic-numbers\n    val === 0 ? 2 * Math.pow(10, -10) : Math.pow(10, -10);\n    var verySmallDate = 1;\n    var minVal = val instanceof Date ? new Date(Number(val) - verySmallDate) : Number(val) - verySmallNumber;\n    var maxVal = val instanceof Date ? new Date(Number(val) + verySmallDate) : Number(val) + verySmallNumber;\n    return val === 0 ? [0, maxVal] : [minVal, maxVal];\n  };\n  return Number(min) === Number(max) ? getSinglePointDomain(max) : [min, max];\n}\n\n/**\n * Returns a the domain for a given axis if domain is given in props\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array|undefined} the domain based on props\n */\nexport function getDomainFromProps(props, axis) {\n  var minDomain = getMinFromProps(props, axis);\n  var maxDomain = getMaxFromProps(props, axis);\n  if (_isPlainObject(props.domain) && props.domain[axis]) {\n    return props.domain[axis];\n  } else if (Array.isArray(props.domain)) {\n    return props.domain;\n  } else if (minDomain !== undefined && maxDomain !== undefined) {\n    return getDomainFromMinMax(minDomain, maxDomain);\n  }\n  return undefined;\n}\n\n/**\n * Returns a domain for a given axis. This method forces the domain to include\n * zero unless the domain is explicitly specified in props.\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\nexport function getDomainWithZero(props, axis) {\n  var propsDomain = getDomainFromProps(props, axis);\n  if (propsDomain) {\n    return propsDomain;\n  }\n  var dataset = Data.getData(props);\n  var y0Min = dataset.reduce(function (min, datum) {\n    return datum._y0 < min ? datum._y0 : min;\n  }, Infinity);\n  var ensureZero = function ensureZero(domain) {\n    if (axis === \"x\") {\n      return domain;\n    }\n    var defaultMin = y0Min !== Infinity ? y0Min : 0;\n    var maxDomainProp = getMaxFromProps(props, axis);\n    var minDomainProp = getMinFromProps(props, axis);\n    var max = maxDomainProp !== undefined ? maxDomainProp : Collection.getMaxValue(domain, defaultMin);\n    var min = minDomainProp !== undefined ? minDomainProp : Collection.getMinValue(domain, defaultMin);\n    return getDomainFromMinMax(min, max);\n  };\n  var getDomainFunction = function getDomainFunction() {\n    return getDomainFromData(props, axis, dataset);\n  };\n  var formatDomainFunction = function formatDomainFunction(domain) {\n    return formatDomain(ensureZero(domain), props, axis);\n  };\n  return createDomainFunction(getDomainFunction, formatDomainFunction)(props, axis);\n}\n\n/**\n * Returns the maxDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the maxDomain based on props\n */\nexport function getMaxFromProps(props, axis) {\n  if (_isPlainObject(props.maxDomain) && props.maxDomain[axis] !== undefined) {\n    return props.maxDomain[axis];\n  }\n  return typeof props.maxDomain === \"number\" || _isDate(props.maxDomain) ? props.maxDomain : undefined;\n}\n\n/**\n * Returns the minDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the minDomain based on props\n */\nexport function getMinFromProps(props, axis) {\n  if (_isPlainObject(props.minDomain) && props.minDomain[axis] !== undefined) {\n    return props.minDomain[axis];\n  }\n  return typeof props.minDomain === \"number\" || _isDate(props.minDomain) ? props.minDomain : undefined;\n}\n\n/**\n * Returns a symmetrically padded domain for polar charts\n * @param {Array} domain: the original domain\n * @param {Array} values: a flat array of values corresponding to either tickValues, or data values\n * for a given dimension i.e. only x values.\n * @returns {Array} the symmetric domain\n */\nexport function getSymmetricDomain(domain, values) {\n  var processedData = _sortedUniq(values.sort(function (a, b) {\n    return a - b;\n  }));\n  var step = processedData[1] - processedData[0];\n  return [domain[0], domain[1] + step];\n}\n\n/**\n * Checks whether a given component can be used to calculate domain\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\nexport function isDomainComponent(component) {\n  var getRole = function getRole(child) {\n    return child && child.type ? child.type.role : \"\";\n  };\n  var role = getRole(component);\n  if (role === \"portal\") {\n    var children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n  var whitelist = [\"area\", \"axis\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"histogram\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return whitelist.includes(role);\n}","map":{"version":3,"names":["_isDate","_sortedUniq","_isPlainObject","React","Data","Scale","Helpers","Collection","cleanDomain","domain","props","axis","scaleType","getScaleType","rules","dom","almostZero","Number","MAX_SAFE_INTEGER","domainOne","domainTwo","getDomainPadding","formatPadding","padding","Array","isArray","left","right","domainPadding","getFlatData","dataset","axisKey","concat","flat","map","datum","undefined","getExtremeFromData","type","getExtreme","arr","Math","max","apply","_toConsumableArray","min","initialValue","Infinity","containsDate","result","reduce","memo","current0","current1","current","Date","padDomain","minDomain","getMinFromProps","maxDomain","getMaxFromProps","getMinValue","getMaxValue","currentAxis","getCurrentAxis","horizontal","range","getRange","rangeExtent","abs","paddedRangeExtent","paddedDomainExtent","valueOf","simplePadding","paddedDomain","singleQuadrantDomainPadding","addsQuadrants","adjust","val","coerce","initialPadding","adjustedDomain","finalPadding","finalDomain","getDomainFromMinMax","createDomainFunction","getDomainFromDataFunction","formatDomainFunction","getDomainFromDataFn","isFunction","getDomainFromData","formatDomainFn","formatDomain","propsDomain","getDomainFromProps","categories","getCategories","getDomainFromCategories","getDomain","categoriesArray","polar","_props$startAngle","startAngle","_props$endAngle","endAngle","stringArray","containsStrings","getStringsFromCategories","stringMap","length","string","index","categoryValues","value","categoryDomain","getSymmetricDomain","datasetArray","getData","_props$startAngle2","_props$endAngle2","getSinglePointDomain","verySmallNumber","pow","verySmallDate","minVal","maxVal","getDomainWithZero","y0Min","_y0","ensureZero","defaultMin","maxDomainProp","minDomainProp","getDomainFunction","values","processedData","sort","a","b","step","isDomainComponent","component","getRole","child","role","children","Children","toArray","whitelist","includes"],"sources":["C:/Users/손한승/Desktop/project-subway/src/main/frontend/node_modules/victory-core/es/victory-util/domain.js"],"sourcesContent":["import _isDate from \"lodash/isDate\";\nimport _sortedUniq from \"lodash/sortedUniq\";\nimport _isPlainObject from \"lodash/isPlainObject\";\n/* eslint-disable no-use-before-define */\nimport React from \"react\";\nimport * as Data from \"./data\";\nimport * as Scale from \"./scale\";\nimport * as Helpers from \"./helpers\";\nimport * as Collection from \"./collection\";\n\n// Private Methods\n\nfunction cleanDomain(domain, props, axis) {\n  const scaleType = Scale.getScaleType(props, axis);\n  if (scaleType !== \"log\") {\n    return domain;\n  }\n  const rules = dom => {\n    const almostZero = dom[0] < 0 || dom[1] < 0 ? -1 / Number.MAX_SAFE_INTEGER : 1 / Number.MAX_SAFE_INTEGER;\n    const domainOne = dom[0] === 0 ? almostZero : dom[0];\n    const domainTwo = dom[1] === 0 ? almostZero : dom[1];\n    return [domainOne, domainTwo];\n  };\n  return rules(domain);\n}\nfunction getDomainPadding(props, axis) {\n  const formatPadding = padding => {\n    return Array.isArray(padding) ? {\n      left: padding[0],\n      right: padding[1]\n    } : {\n      left: padding,\n      right: padding\n    };\n  };\n  return _isPlainObject(props.domainPadding) ? formatPadding(props.domainPadding[axis]) : formatPadding(props.domainPadding);\n}\nfunction getFlatData(dataset, axis) {\n  const axisKey = `_${axis}`;\n  return dataset.flat().map(datum => {\n    return datum[axisKey] && datum[axisKey][1] !== undefined ? datum[axisKey][1] : datum[axisKey];\n  });\n}\nfunction getExtremeFromData(dataset, axis, type) {\n  if (type === void 0) {\n    type = \"min\";\n  }\n  const getExtreme = arr => type === \"max\" ? Math.max(...arr) : Math.min(...arr);\n  const initialValue = type === \"max\" ? -Infinity : Infinity;\n  let containsDate = false;\n  const result = dataset.flat().reduce((memo, datum) => {\n    const current0 = datum[`_${axis}0`] !== undefined ? datum[`_${axis}0`] : datum[`_${axis}`];\n    const current1 = datum[`_${axis}1`] !== undefined ? datum[`_${axis}1`] : datum[`_${axis}`];\n    const current = getExtreme([current0, current1]);\n    containsDate = containsDate || current0 instanceof Date || current1 instanceof Date;\n    return getExtreme([memo, current]);\n  }, initialValue);\n  return containsDate ? new Date(result) : result;\n}\n\n// eslint-disable-next-line max-statements\nfunction padDomain(domain, props, axis) {\n  if (!props.domainPadding) {\n    return domain;\n  }\n  const minDomain = getMinFromProps(props, axis);\n  const maxDomain = getMaxFromProps(props, axis);\n  const padding = getDomainPadding(props, axis);\n  if (!padding.left && !padding.right) {\n    return domain;\n  }\n  const min = Collection.getMinValue(domain);\n  const max = Collection.getMaxValue(domain);\n  const currentAxis = Helpers.getCurrentAxis(axis, props.horizontal);\n  const range = Helpers.getRange(props, currentAxis);\n  const rangeExtent = Math.abs(range[0] - range[1]);\n  const paddedRangeExtent = Math.max(rangeExtent - padding.left - padding.right, 1);\n  const paddedDomainExtent = Math.abs(max.valueOf() - min.valueOf()) / paddedRangeExtent * rangeExtent;\n  const simplePadding = {\n    left: paddedDomainExtent * padding.left / rangeExtent,\n    right: paddedDomainExtent * padding.right / rangeExtent\n  };\n  let paddedDomain = {\n    min: min.valueOf() - simplePadding.left,\n    max: max.valueOf() + simplePadding.right\n  };\n  const singleQuadrantDomainPadding = _isPlainObject(props.singleQuadrantDomainPadding) ? props.singleQuadrantDomainPadding[axis] : props.singleQuadrantDomainPadding;\n  const addsQuadrants = min >= 0 && paddedDomain.min <= 0 || max <= 0 && paddedDomain.max >= 0;\n  const adjust = (val, type) => {\n    const coerce = type === \"min\" && min >= 0 && val <= 0 || type === \"max\" && max <= 0 && val >= 0;\n    return coerce ? 0 : val;\n  };\n  if (addsQuadrants && singleQuadrantDomainPadding !== false) {\n    // Naive initial padding calculation\n    const initialPadding = {\n      // @ts-expect-error `max/min` might be dates\n      left: Math.abs(max - min) * padding.left / rangeExtent,\n      // @ts-expect-error `max/min` might be dates\n      right: Math.abs(max - min) * padding.right / rangeExtent\n    };\n\n    // Adjust the domain by the initial padding\n    const adjustedDomain = {\n      min: adjust(min.valueOf() - initialPadding.left, \"min\"),\n      max: adjust(max.valueOf() + initialPadding.right, \"max\")\n    };\n\n    // re-calculate padding, taking the adjusted domain into account\n    const finalPadding = {\n      left: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.left / rangeExtent,\n      right: Math.abs(adjustedDomain.max - adjustedDomain.min) * padding.right / rangeExtent\n    };\n\n    // Adjust the domain by the final padding\n    paddedDomain = {\n      min: adjust(min.valueOf() - finalPadding.left, \"min\"),\n      max: adjust(max.valueOf() + finalPadding.right, \"max\")\n    };\n  }\n\n  // default to minDomain / maxDomain if they exist\n  const finalDomain = {\n    min: minDomain !== undefined ? minDomain : paddedDomain.min,\n    max: maxDomain !== undefined ? maxDomain : paddedDomain.max\n  };\n  return min instanceof Date || max instanceof Date ? getDomainFromMinMax(new Date(finalDomain.min), new Date(finalDomain.max)) : getDomainFromMinMax(finalDomain.min, finalDomain.max);\n}\n\n// Public Methods\n\n/**\n * Returns a getDomain function\n * @param {Function} getDomainFromDataFunction: a function that takes props and axis and\n * returns a domain based on data\n * @param {Function} formatDomainFunction: a function that takes domain, props, and axis and\n * returns a formatted domain\n * @returns {Function} a function that takes props and axis and returns a formatted domain\n */\nexport function createDomainFunction(getDomainFromDataFunction, formatDomainFunction) {\n  const getDomainFromDataFn = Helpers.isFunction(getDomainFromDataFunction) ? getDomainFromDataFunction : getDomainFromData;\n  const formatDomainFn = Helpers.isFunction(formatDomainFunction) ? formatDomainFunction : formatDomain;\n  return (props, axis) => {\n    const propsDomain = getDomainFromProps(props, axis);\n    if (propsDomain) {\n      return formatDomainFn(propsDomain, props, axis);\n    }\n    const categories = Data.getCategories(props, axis);\n    const domain = categories ? getDomainFromCategories(props, axis, categories) : getDomainFromDataFn(props, axis);\n    return domain ? formatDomainFn(domain, props, axis) : undefined;\n  };\n}\n\n/**\n * Returns a formatted domain.\n * @param {Array} domain: a domain in the form of a two element array\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} a domain in the form of a two element array\n */\nexport function formatDomain(domain, props, axis) {\n  return cleanDomain(padDomain(domain, props, axis), props, axis);\n}\n\n/**\n * Returns a domain for a given axis based on props, category, or data\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\nexport function getDomain(props, axis) {\n  return createDomainFunction()(props, axis);\n}\n\n/**\n * Returns a domain based on categories if they exist\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} categories: an array of categories corresponding to a given axis\n * @returns {Array|undefined} returns a domain from categories or undefined\n */\nexport function getDomainFromCategories(props, axis, categories) {\n  const categoriesArray = categories || Data.getCategories(props, axis);\n  const {\n    polar,\n    startAngle = 0,\n    endAngle = 360\n  } = props;\n  if (!categoriesArray) {\n    return undefined;\n  }\n  const minDomain = getMinFromProps(props, axis);\n  const maxDomain = getMaxFromProps(props, axis);\n  const stringArray = Collection.containsStrings(categoriesArray) ? Data.getStringsFromCategories(props, axis) : [];\n  const stringMap = stringArray.length === 0 ? null : stringArray.reduce((memo, string, index) => {\n    memo[string] = index + 1;\n    return memo;\n  }, {});\n  const categoryValues = stringMap ? categoriesArray.map(value => stringMap[value]) : categoriesArray;\n  const min = minDomain !== undefined ? minDomain : Collection.getMinValue(categoryValues);\n  const max = maxDomain !== undefined ? maxDomain : Collection.getMaxValue(categoryValues);\n  const categoryDomain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(categoryDomain, categoryValues) : categoryDomain;\n}\n\n/**\n * Returns a domain from a dataset for a given axis\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @param {Array} dataset: an array of data\n * @returns {Array} the domain based on data\n */\nexport function getDomainFromData(props, axis, dataset) {\n  const datasetArray = dataset || Data.getData(props);\n  const {\n    polar,\n    startAngle = 0,\n    endAngle = 360\n  } = props;\n  const minDomain = getMinFromProps(props, axis);\n  const maxDomain = getMaxFromProps(props, axis);\n  if (datasetArray.length < 1) {\n    return minDomain !== undefined && maxDomain !== undefined ? getDomainFromMinMax(minDomain, maxDomain) : undefined;\n  }\n  const min = minDomain !== undefined ? minDomain : getExtremeFromData(datasetArray, axis, \"min\");\n  const max = maxDomain !== undefined ? maxDomain : getExtremeFromData(datasetArray, axis, \"max\");\n  const domain = getDomainFromMinMax(min, max);\n  return polar && axis === \"x\" && Math.abs(startAngle - endAngle) === 360 ? getSymmetricDomain(domain, getFlatData(datasetArray, axis)) : domain;\n}\n\n/**\n * Returns a domain in the form of a two element array given a min and max value.\n * @param {Number|Date} min: the props object\n * @param {Number|Date} max: the current axis\n * @returns {Array} the minDomain based on props\n */\nexport function getDomainFromMinMax(min, max) {\n  const getSinglePointDomain = val => {\n    // d3-scale does not properly resolve very small differences.\n    const verySmallNumber =\n    // eslint-disable-next-line no-magic-numbers\n    val === 0 ? 2 * Math.pow(10, -10) : Math.pow(10, -10);\n    const verySmallDate = 1;\n    const minVal = val instanceof Date ? new Date(Number(val) - verySmallDate) : Number(val) - verySmallNumber;\n    const maxVal = val instanceof Date ? new Date(Number(val) + verySmallDate) : Number(val) + verySmallNumber;\n    return val === 0 ? [0, maxVal] : [minVal, maxVal];\n  };\n  return Number(min) === Number(max) ? getSinglePointDomain(max) : [min, max];\n}\n\n/**\n * Returns a the domain for a given axis if domain is given in props\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array|undefined} the domain based on props\n */\nexport function getDomainFromProps(props, axis) {\n  const minDomain = getMinFromProps(props, axis);\n  const maxDomain = getMaxFromProps(props, axis);\n  if (_isPlainObject(props.domain) && props.domain[axis]) {\n    return props.domain[axis];\n  } else if (Array.isArray(props.domain)) {\n    return props.domain;\n  } else if (minDomain !== undefined && maxDomain !== undefined) {\n    return getDomainFromMinMax(minDomain, maxDomain);\n  }\n  return undefined;\n}\n\n/**\n * Returns a domain for a given axis. This method forces the domain to include\n * zero unless the domain is explicitly specified in props.\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Array} the domain for the given axis\n */\nexport function getDomainWithZero(props, axis) {\n  const propsDomain = getDomainFromProps(props, axis);\n  if (propsDomain) {\n    return propsDomain;\n  }\n  const dataset = Data.getData(props);\n  const y0Min = dataset.reduce((min, datum) => datum._y0 < min ? datum._y0 : min, Infinity);\n  const ensureZero = domain => {\n    if (axis === \"x\") {\n      return domain;\n    }\n    const defaultMin = y0Min !== Infinity ? y0Min : 0;\n    const maxDomainProp = getMaxFromProps(props, axis);\n    const minDomainProp = getMinFromProps(props, axis);\n    const max = maxDomainProp !== undefined ? maxDomainProp : Collection.getMaxValue(domain, defaultMin);\n    const min = minDomainProp !== undefined ? minDomainProp : Collection.getMinValue(domain, defaultMin);\n    return getDomainFromMinMax(min, max);\n  };\n  const getDomainFunction = () => {\n    return getDomainFromData(props, axis, dataset);\n  };\n  const formatDomainFunction = domain => {\n    return formatDomain(ensureZero(domain), props, axis);\n  };\n  return createDomainFunction(getDomainFunction, formatDomainFunction)(props, axis);\n}\n\n/**\n * Returns the maxDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the maxDomain based on props\n */\nexport function getMaxFromProps(props, axis) {\n  if (_isPlainObject(props.maxDomain) && props.maxDomain[axis] !== undefined) {\n    return props.maxDomain[axis];\n  }\n  return typeof props.maxDomain === \"number\" || _isDate(props.maxDomain) ? props.maxDomain : undefined;\n}\n\n/**\n * Returns the minDomain from props if it exists\n * @param {Object} props: the props object\n * @param {String} axis: the current axis\n * @returns {Number|Date|undefined} the minDomain based on props\n */\nexport function getMinFromProps(props, axis) {\n  if (_isPlainObject(props.minDomain) && props.minDomain[axis] !== undefined) {\n    return props.minDomain[axis];\n  }\n  return typeof props.minDomain === \"number\" || _isDate(props.minDomain) ? props.minDomain : undefined;\n}\n\n/**\n * Returns a symmetrically padded domain for polar charts\n * @param {Array} domain: the original domain\n * @param {Array} values: a flat array of values corresponding to either tickValues, or data values\n * for a given dimension i.e. only x values.\n * @returns {Array} the symmetric domain\n */\nexport function getSymmetricDomain(domain, values) {\n  const processedData = _sortedUniq(values.sort((a, b) => a - b));\n  const step = processedData[1] - processedData[0];\n  return [domain[0], domain[1] + step];\n}\n\n/**\n * Checks whether a given component can be used to calculate domain\n * @param {Component} component: a React component instance\n * @returns {Boolean} Returns true if the given component has a role included in the whitelist\n */\nexport function isDomainComponent(component) {\n  const getRole = child => {\n    return child && child.type ? child.type.role : \"\";\n  };\n  let role = getRole(component);\n  if (role === \"portal\") {\n    const children = React.Children.toArray(component.props.children);\n    role = children.length ? getRole(children[0]) : \"\";\n  }\n  const whitelist = [\"area\", \"axis\", \"bar\", \"boxplot\", \"candlestick\", \"errorbar\", \"group\", \"histogram\", \"line\", \"pie\", \"scatter\", \"stack\", \"voronoi\"];\n  return whitelist.includes(role);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
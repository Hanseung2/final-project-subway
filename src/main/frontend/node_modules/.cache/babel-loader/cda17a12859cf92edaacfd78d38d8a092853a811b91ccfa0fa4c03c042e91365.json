{"ast":null,"code":"import _identity from \"lodash/identity\";\nimport _defaults from \"lodash/defaults\";\nimport React from \"react\";\nfunction getDatumKey(datum, idx) {\n  return (datum.key || idx).toString();\n}\nfunction getKeyedData(data) {\n  return data.reduce(function (keyedData, datum, idx) {\n    var key = getDatumKey(datum, idx);\n    keyedData[key] = datum;\n    return keyedData;\n  }, {});\n}\nfunction getKeyedDataDifference(a, b) {\n  var hasDifference = false;\n  var difference = Object.keys(a).reduce(function (_difference, key) {\n    if (!(key in b)) {\n      hasDifference = true;\n      _difference[key] = true;\n    }\n    return _difference;\n  }, {});\n  return hasDifference && difference;\n}\n\n/**\n * Calculate which data-points exist in oldData and not nextData -\n * these are the `exiting` data-points.  Also calculate which\n * data-points exist in nextData and not oldData - these are the\n * `entering` data-points.\n *\n * @param  {Array} oldData   this.props.data Array\n * @param  {Array} nextData  this.props.data Array\n *\n * @return {Object}          Object with `entering` and `exiting` properties.\n *                           entering[datum.key] will be true if the data is\n *                           entering, and similarly for `exiting`.\n */\nfunction getNodeTransitions(oldData, nextData) {\n  var oldDataKeyed = oldData && getKeyedData(oldData);\n  var nextDataKeyed = nextData && getKeyedData(nextData);\n  return {\n    entering: oldDataKeyed && getKeyedDataDifference(nextDataKeyed, oldDataKeyed),\n    exiting: nextDataKeyed && getKeyedDataDifference(oldDataKeyed, nextDataKeyed)\n  };\n}\nfunction getChildData(child) {\n  if (child.type && child.type.getData) {\n    return child.type.getData(child.props);\n  }\n  return child.props && child.props.data || false;\n}\n\n/**\n * If a parent component has animation enabled, calculate the transitions\n * for any data of any child component that supports data transitions.\n * Data transitions are defined as any two datasets where data nodes exist\n * in the first set and not the second, in the second and not the first,\n * or both.\n *\n * @param  {Children}  oldChildren   this.props.children from old props\n * @param  {Children}  nextChildren  this.props.children from next props\n *\n * @return {Object}                  Object with the following properties:\n *                                    - nodesWillExit\n *                                    - nodesWillEnter\n *                                    - childrenTransitions\n *                                    - nodesShouldEnter\n */\nexport function getInitialTransitionState(oldChildren, nextChildren) {\n  var nodesWillExit = false;\n  var nodesWillEnter = false;\n  var getTransition = function getTransition(oldChild, newChild) {\n    if (!newChild || oldChild.type !== newChild.type) {\n      return {};\n    }\n    var _ref = getNodeTransitions(getChildData(oldChild), getChildData(newChild)) || {},\n      entering = _ref.entering,\n      exiting = _ref.exiting;\n    nodesWillExit = nodesWillExit || !!exiting;\n    nodesWillEnter = nodesWillEnter || !!entering;\n    return {\n      entering: entering || false,\n      exiting: exiting || false\n    };\n  };\n  var getTransitionsFromChildren = function getTransitionsFromChildren(old, next) {\n    return old.map(function (child, idx) {\n      if (child && child.props && child.props.children && next[idx]) {\n        return getTransitionsFromChildren(React.Children.toArray(old[idx].props.children), React.Children.toArray(next[idx].props.children));\n      }\n      // get Transition entering and exiting nodes\n      return getTransition(child, next[idx]);\n    });\n  };\n  var childrenTransitions = getTransitionsFromChildren(React.Children.toArray(oldChildren), React.Children.toArray(nextChildren));\n  return {\n    nodesWillExit: nodesWillExit,\n    nodesWillEnter: nodesWillEnter,\n    childrenTransitions: childrenTransitions,\n    // TODO: This may need to be refactored for the following situation.\n    //       The component receives new props, and the data provided\n    //       is a perfect match for the previous data and domain except\n    //       for new nodes. In this case, we wouldn't want a delay before\n    //       the new nodes appear.\n    nodesShouldEnter: false\n  };\n}\nfunction getInitialChildProps(animate, data) {\n  var after = animate.onEnter && animate.onEnter.after ? animate.onEnter.after : _identity;\n  return {\n    data: data.map(function (datum, idx) {\n      return Object.assign({}, datum, after(datum, idx, data));\n    })\n  };\n}\n\n// eslint-disable-next-line max-params\nfunction getChildBeforeLoad(animate, child, data, cb) {\n  var newAnimate = Object.assign({}, animate, {\n    onEnd: cb\n  });\n  if (newAnimate && newAnimate.onLoad && !newAnimate.onLoad.duration) {\n    return {\n      animate: newAnimate,\n      data: data\n    };\n  }\n  var before = newAnimate.onLoad && newAnimate.onLoad.before ? newAnimate.onLoad.before : _identity;\n  // If nodes need to exit, transform them with the provided onLoad.before function.\n  var newData = data.map(function (datum, idx) {\n    return Object.assign({}, datum, before(datum, idx, data));\n  });\n  return {\n    animate: newAnimate,\n    data: newData,\n    clipWidth: 0\n  };\n}\n\n// eslint-disable-next-line max-params\nfunction getChildOnLoad(animate, data, cb) {\n  var newAnimate = Object.assign({}, animate, {\n    onEnd: cb\n  });\n  var newData = data;\n  if (newAnimate && newAnimate.onLoad && !newAnimate.onLoad.duration) {\n    return {\n      animate: animate,\n      data: data\n    };\n  }\n  var after = animate.onLoad && animate.onLoad.after ? animate.onLoad.after : _identity;\n  // If nodes need to exit, transform them with the provided onLoad.after function.\n  newData = data.map(function (datum, idx) {\n    return Object.assign({}, datum, after(datum, idx, data));\n  });\n  return {\n    animate: newAnimate,\n    data: newData\n  };\n}\n\n// eslint-disable-next-line max-params, max-len\nfunction getChildPropsOnExit(animate, child, data, exitingNodes, cb) {\n  // Whether or not _this_ child has exiting nodes, we want the exit-\n  // transition for all children to have the same duration, delay, etc.\n  var onExit = animate && animate.onExit;\n  var newAnimate = Object.assign({}, animate, onExit);\n  var newData = data;\n  if (exitingNodes) {\n    // After the exit transition occurs, trigger the animations for\n    // nodes that are neither exiting nor entering.\n    animate.onEnd = cb;\n    var before = animate.onExit && animate.onExit.before ? animate.onExit.before : _identity;\n    // If nodes need to exit, transform them with the provided onExit.before function.\n    newData = data.map(function (datum, idx) {\n      var key = (datum.key || idx).toString();\n      return exitingNodes[key] ? Object.assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n  return {\n    animate: newAnimate,\n    data: newData\n  };\n}\n\n// eslint-disable-next-line max-params,max-len\nfunction getChildPropsBeforeEnter(animate, child, data, enteringNodes, cb) {\n  var newAnimate = animate;\n  var newData = data;\n  if (enteringNodes) {\n    // Perform a normal animation here, except - when it finishes - trigger\n    // the transition for entering nodes.\n    newAnimate = Object.assign({}, animate, {\n      onEnd: cb\n    });\n    var before = animate.onEnter && animate.onEnter.before ? animate.onEnter.before : _identity;\n    // We want the entering nodes to be included in the transition target\n    // domain.  However, we may not want these nodes to be displayed initially,\n    // so perform the `onEnter.before` transformation on each node.\n    newData = data.map(function (datum, idx) {\n      var key = (datum.key || idx).toString();\n      return enteringNodes[key] ? Object.assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n  return {\n    animate: newAnimate,\n    data: newData\n  };\n}\n\n// eslint-disable-next-line max-params, max-len\nfunction getChildPropsOnEnter(animate, data, enteringNodes, cb) {\n  // Whether or not _this_ child has entering nodes, we want the entering-\n  // transition for all children to have the same duration, delay, etc.\n  var onEnter = animate && animate.onEnter;\n  var newAnimate = Object.assign({}, animate, onEnter);\n  var newData = data;\n  if (enteringNodes) {\n    // Old nodes have been transitioned to their new values, and the\n    // domain should encompass the nodes that will now enter. So perform\n    // the `onEnter.after` transformation on each node.\n    newAnimate.onEnd = cb;\n    var after = newAnimate.onEnter && newAnimate.onEnter.after ? newAnimate.onEnter.after : _identity;\n    newData = data.map(function (datum, idx) {\n      var key = getDatumKey(datum, idx);\n      return enteringNodes[key] ? Object.assign({}, datum, after(datum, idx, data)) : datum;\n    });\n  }\n  return {\n    animate: newAnimate,\n    data: newData\n  };\n}\n\n/**\n * getTransitionPropsFactory - putting the Java in JavaScript.  This will return a\n * function that returns prop transformations for a child, given that child's props\n * and its index in the parent's children array.\n *\n * In particular, this will include an `animate` object that is set appropriately\n * so that each child will be synchronized for each stage of a transition\n * animation.  It will also include a transformed `data` object, where each datum\n * is transformed by `animate.onExit` and `animate.onEnter` `before` and `after`\n * functions.\n *\n * @param  {Object}  props       `this.props` for the parent component.\n * @param  {Object} state        `this.state` for the parent component.\n * @param  {Function} setState    Function that, when called, will `this.setState` on\n *                                 the parent component with the provided object.\n *\n * @return {Function}              Child-prop transformation function.\n */\nexport function getTransitionPropsFactory(props, state, setState) {\n  var nodesWillExit = state && state.nodesWillExit;\n  var nodesWillEnter = state && state.nodesWillEnter;\n  var nodesShouldEnter = state && state.nodesShouldEnter;\n  var nodesShouldLoad = state && state.nodesShouldLoad;\n  var nodesDoneLoad = state && state.nodesDoneLoad;\n  var childrenTransitions = state && state.childrenTransitions || [];\n  var transitionDurations = {\n    enter: props.animate && props.animate.onEnter && props.animate.onEnter.duration,\n    exit: props.animate && props.animate.onExit && props.animate.onExit.duration,\n    load: props.animate && props.animate.onLoad && props.animate.onLoad.duration,\n    move: props.animate && props.animate.duration\n  };\n  var onLoad = function onLoad(child, data, animate) {\n    if (nodesShouldLoad) {\n      return getChildOnLoad(animate, data, function () {\n        setState({\n          nodesShouldLoad: false,\n          nodesDoneLoad: true\n        });\n      });\n    }\n    return getChildBeforeLoad(animate, child, data, function () {\n      setState({\n        nodesDoneLoad: true\n      });\n    });\n  };\n\n  // eslint-disable-next-line max-params\n  var onExit = function onExit(nodes, child, data, animate) {\n    return getChildPropsOnExit(animate, child, data, nodes, function () {\n      setState({\n        nodesWillExit: false\n      });\n    });\n  };\n\n  // eslint-disable-next-line max-params\n  var onEnter = function onEnter(nodes, child, data, animate) {\n    if (nodesShouldEnter) {\n      return getChildPropsOnEnter(animate, data, nodes, function () {\n        setState({\n          nodesWillEnter: false\n        });\n      });\n    }\n    return getChildPropsBeforeEnter(animate, child, data, nodes, function () {\n      setState({\n        nodesShouldEnter: true\n      });\n    });\n  };\n  var getChildTransitionDuration = function getChildTransitionDuration(child, type) {\n    var animate = child.props.animate;\n    if (!child.type) {\n      return {};\n    }\n    var defaultTransitions = child.props && child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n    if (defaultTransitions) {\n      var animationDuration = animate[type] && animate[type].duration;\n      return animationDuration !== undefined ? animationDuration : defaultTransitions[type] && defaultTransitions[type].duration;\n    }\n    return {};\n  };\n\n  // eslint-disable-next-line max-statements, complexity, max-len\n  return function getTransitionProps(child, index) {\n    var data = getChildData(child) || [];\n    var animate = _defaults({}, props.animate, child.props.animate);\n    var defaultTransitions = child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n    animate.onExit = _defaults({}, animate.onExit, defaultTransitions && defaultTransitions.onExit);\n    animate.onEnter = _defaults({}, animate.onEnter, defaultTransitions && defaultTransitions.onEnter);\n    animate.onLoad = _defaults({}, animate.onLoad, defaultTransitions && defaultTransitions.onLoad);\n    var childTransitions = childrenTransitions[index] || childrenTransitions[0];\n    if (!nodesDoneLoad) {\n      // should do onLoad animation\n      var load = transitionDurations.load !== undefined ? transitionDurations.load : getChildTransitionDuration(child, \"onLoad\");\n      var animation = {\n        duration: load\n      };\n      return onLoad(child, data, Object.assign({}, animate, animation));\n    } else if (nodesWillExit) {\n      var exitingNodes = childTransitions && childTransitions.exiting;\n      var exit = transitionDurations.exit !== undefined ? transitionDurations.exit : getChildTransitionDuration(child, \"onExit\");\n      // if nodesWillExit, but this child has no exiting nodes, set a delay instead of a duration\n      var _animation = exitingNodes ? {\n        duration: exit\n      } : {\n        delay: exit\n      };\n      return onExit(exitingNodes, child, data, Object.assign({}, animate, _animation));\n    } else if (nodesWillEnter) {\n      var enteringNodes = childTransitions && childTransitions.entering;\n      var enter = transitionDurations.enter !== undefined ? transitionDurations.enter : getChildTransitionDuration(child, \"onEnter\");\n      var move = transitionDurations.move !== undefined ? transitionDurations.move : child.props.animate && child.props.animate.duration;\n      var _animation2 = {\n        duration: nodesShouldEnter && enteringNodes ? enter : move\n      };\n      return onEnter(enteringNodes, child, data, Object.assign({}, animate, _animation2));\n    } else if (!state && animate && animate.onExit) {\n      // This is the initial render, and nodes may enter when props change. Because\n      // animation interpolation is determined by old- and next- props, data may need\n      // to be augmented with certain properties.\n      //\n      // For example, it may be desired that exiting nodes go from `opacity: 1` to\n      // `opacity: 0`. Without setting this on a per-datum basis, the interpolation\n      // might go from `opacity: undefined` to `opacity: 0`, which would result in\n      // interpolated `opacity: NaN` values.\n      //\n      return getInitialChildProps(animate, data);\n    }\n    return {\n      animate: animate,\n      data: data\n    };\n  };\n}","map":{"version":3,"names":["_identity","_defaults","React","getDatumKey","datum","idx","key","toString","getKeyedData","data","reduce","keyedData","getKeyedDataDifference","a","b","hasDifference","difference","Object","keys","_difference","getNodeTransitions","oldData","nextData","oldDataKeyed","nextDataKeyed","entering","exiting","getChildData","child","type","getData","props","getInitialTransitionState","oldChildren","nextChildren","nodesWillExit","nodesWillEnter","getTransition","oldChild","newChild","_ref","getTransitionsFromChildren","old","next","map","children","Children","toArray","childrenTransitions","nodesShouldEnter","getInitialChildProps","animate","after","onEnter","assign","getChildBeforeLoad","cb","newAnimate","onEnd","onLoad","duration","before","newData","clipWidth","getChildOnLoad","getChildPropsOnExit","exitingNodes","onExit","getChildPropsBeforeEnter","enteringNodes","getChildPropsOnEnter","getTransitionPropsFactory","state","setState","nodesShouldLoad","nodesDoneLoad","transitionDurations","enter","exit","load","move","nodes","getChildTransitionDuration","defaultTransitions","polar","defaultPolarTransitions","animationDuration","undefined","getTransitionProps","index","childTransitions","animation","delay"],"sources":["C:/Users/손한승/Desktop/project-subway/src/main/frontend/node_modules/victory-core/es/victory-util/transitions.js"],"sourcesContent":["import _identity from \"lodash/identity\";\nimport _defaults from \"lodash/defaults\";\nimport React from \"react\";\nfunction getDatumKey(datum, idx) {\n  return (datum.key || idx).toString();\n}\nfunction getKeyedData(data) {\n  return data.reduce((keyedData, datum, idx) => {\n    const key = getDatumKey(datum, idx);\n    keyedData[key] = datum;\n    return keyedData;\n  }, {});\n}\nfunction getKeyedDataDifference(a, b) {\n  let hasDifference = false;\n  const difference = Object.keys(a).reduce((_difference, key) => {\n    if (!(key in b)) {\n      hasDifference = true;\n      _difference[key] = true;\n    }\n    return _difference;\n  }, {});\n  return hasDifference && difference;\n}\n\n/**\n * Calculate which data-points exist in oldData and not nextData -\n * these are the `exiting` data-points.  Also calculate which\n * data-points exist in nextData and not oldData - these are the\n * `entering` data-points.\n *\n * @param  {Array} oldData   this.props.data Array\n * @param  {Array} nextData  this.props.data Array\n *\n * @return {Object}          Object with `entering` and `exiting` properties.\n *                           entering[datum.key] will be true if the data is\n *                           entering, and similarly for `exiting`.\n */\nfunction getNodeTransitions(oldData, nextData) {\n  const oldDataKeyed = oldData && getKeyedData(oldData);\n  const nextDataKeyed = nextData && getKeyedData(nextData);\n  return {\n    entering: oldDataKeyed && getKeyedDataDifference(nextDataKeyed, oldDataKeyed),\n    exiting: nextDataKeyed && getKeyedDataDifference(oldDataKeyed, nextDataKeyed)\n  };\n}\nfunction getChildData(child) {\n  if (child.type && child.type.getData) {\n    return child.type.getData(child.props);\n  }\n  return child.props && child.props.data || false;\n}\n\n/**\n * If a parent component has animation enabled, calculate the transitions\n * for any data of any child component that supports data transitions.\n * Data transitions are defined as any two datasets where data nodes exist\n * in the first set and not the second, in the second and not the first,\n * or both.\n *\n * @param  {Children}  oldChildren   this.props.children from old props\n * @param  {Children}  nextChildren  this.props.children from next props\n *\n * @return {Object}                  Object with the following properties:\n *                                    - nodesWillExit\n *                                    - nodesWillEnter\n *                                    - childrenTransitions\n *                                    - nodesShouldEnter\n */\nexport function getInitialTransitionState(oldChildren, nextChildren) {\n  let nodesWillExit = false;\n  let nodesWillEnter = false;\n  const getTransition = (oldChild, newChild) => {\n    if (!newChild || oldChild.type !== newChild.type) {\n      return {};\n    }\n    const {\n      entering,\n      exiting\n    } = getNodeTransitions(getChildData(oldChild), getChildData(newChild)) || {};\n    nodesWillExit = nodesWillExit || !!exiting;\n    nodesWillEnter = nodesWillEnter || !!entering;\n    return {\n      entering: entering || false,\n      exiting: exiting || false\n    };\n  };\n  const getTransitionsFromChildren = (old, next) => {\n    return old.map((child, idx) => {\n      if (child && child.props && child.props.children && next[idx]) {\n        return getTransitionsFromChildren(React.Children.toArray(old[idx].props.children), React.Children.toArray(next[idx].props.children));\n      }\n      // get Transition entering and exiting nodes\n      return getTransition(child, next[idx]);\n    });\n  };\n  const childrenTransitions = getTransitionsFromChildren(React.Children.toArray(oldChildren), React.Children.toArray(nextChildren));\n  return {\n    nodesWillExit,\n    nodesWillEnter,\n    childrenTransitions,\n    // TODO: This may need to be refactored for the following situation.\n    //       The component receives new props, and the data provided\n    //       is a perfect match for the previous data and domain except\n    //       for new nodes. In this case, we wouldn't want a delay before\n    //       the new nodes appear.\n    nodesShouldEnter: false\n  };\n}\nfunction getInitialChildProps(animate, data) {\n  const after = animate.onEnter && animate.onEnter.after ? animate.onEnter.after : _identity;\n  return {\n    data: data.map((datum, idx) => Object.assign({}, datum, after(datum, idx, data)))\n  };\n}\n\n// eslint-disable-next-line max-params\nfunction getChildBeforeLoad(animate, child, data, cb) {\n  const newAnimate = Object.assign({}, animate, {\n    onEnd: cb\n  });\n  if (newAnimate && newAnimate.onLoad && !newAnimate.onLoad.duration) {\n    return {\n      animate: newAnimate,\n      data\n    };\n  }\n  const before = newAnimate.onLoad && newAnimate.onLoad.before ? newAnimate.onLoad.before : _identity;\n  // If nodes need to exit, transform them with the provided onLoad.before function.\n  const newData = data.map((datum, idx) => {\n    return Object.assign({}, datum, before(datum, idx, data));\n  });\n  return {\n    animate: newAnimate,\n    data: newData,\n    clipWidth: 0\n  };\n}\n\n// eslint-disable-next-line max-params\nfunction getChildOnLoad(animate, data, cb) {\n  const newAnimate = Object.assign({}, animate, {\n    onEnd: cb\n  });\n  let newData = data;\n  if (newAnimate && newAnimate.onLoad && !newAnimate.onLoad.duration) {\n    return {\n      animate,\n      data\n    };\n  }\n  const after = animate.onLoad && animate.onLoad.after ? animate.onLoad.after : _identity;\n  // If nodes need to exit, transform them with the provided onLoad.after function.\n  newData = data.map((datum, idx) => {\n    return Object.assign({}, datum, after(datum, idx, data));\n  });\n  return {\n    animate: newAnimate,\n    data: newData\n  };\n}\n\n// eslint-disable-next-line max-params, max-len\nfunction getChildPropsOnExit(animate, child, data, exitingNodes, cb) {\n  // Whether or not _this_ child has exiting nodes, we want the exit-\n  // transition for all children to have the same duration, delay, etc.\n  const onExit = animate && animate.onExit;\n  const newAnimate = Object.assign({}, animate, onExit);\n  let newData = data;\n  if (exitingNodes) {\n    // After the exit transition occurs, trigger the animations for\n    // nodes that are neither exiting nor entering.\n    animate.onEnd = cb;\n    const before = animate.onExit && animate.onExit.before ? animate.onExit.before : _identity;\n    // If nodes need to exit, transform them with the provided onExit.before function.\n    newData = data.map((datum, idx) => {\n      const key = (datum.key || idx).toString();\n      return exitingNodes[key] ? Object.assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n  return {\n    animate: newAnimate,\n    data: newData\n  };\n}\n\n// eslint-disable-next-line max-params,max-len\nfunction getChildPropsBeforeEnter(animate, child, data, enteringNodes, cb) {\n  let newAnimate = animate;\n  let newData = data;\n  if (enteringNodes) {\n    // Perform a normal animation here, except - when it finishes - trigger\n    // the transition for entering nodes.\n    newAnimate = Object.assign({}, animate, {\n      onEnd: cb\n    });\n    const before = animate.onEnter && animate.onEnter.before ? animate.onEnter.before : _identity;\n    // We want the entering nodes to be included in the transition target\n    // domain.  However, we may not want these nodes to be displayed initially,\n    // so perform the `onEnter.before` transformation on each node.\n    newData = data.map((datum, idx) => {\n      const key = (datum.key || idx).toString();\n      return enteringNodes[key] ? Object.assign({}, datum, before(datum, idx, data)) : datum;\n    });\n  }\n  return {\n    animate: newAnimate,\n    data: newData\n  };\n}\n\n// eslint-disable-next-line max-params, max-len\nfunction getChildPropsOnEnter(animate, data, enteringNodes, cb) {\n  // Whether or not _this_ child has entering nodes, we want the entering-\n  // transition for all children to have the same duration, delay, etc.\n  const onEnter = animate && animate.onEnter;\n  const newAnimate = Object.assign({}, animate, onEnter);\n  let newData = data;\n  if (enteringNodes) {\n    // Old nodes have been transitioned to their new values, and the\n    // domain should encompass the nodes that will now enter. So perform\n    // the `onEnter.after` transformation on each node.\n    newAnimate.onEnd = cb;\n    const after = newAnimate.onEnter && newAnimate.onEnter.after ? newAnimate.onEnter.after : _identity;\n    newData = data.map((datum, idx) => {\n      const key = getDatumKey(datum, idx);\n      return enteringNodes[key] ? Object.assign({}, datum, after(datum, idx, data)) : datum;\n    });\n  }\n  return {\n    animate: newAnimate,\n    data: newData\n  };\n}\n\n/**\n * getTransitionPropsFactory - putting the Java in JavaScript.  This will return a\n * function that returns prop transformations for a child, given that child's props\n * and its index in the parent's children array.\n *\n * In particular, this will include an `animate` object that is set appropriately\n * so that each child will be synchronized for each stage of a transition\n * animation.  It will also include a transformed `data` object, where each datum\n * is transformed by `animate.onExit` and `animate.onEnter` `before` and `after`\n * functions.\n *\n * @param  {Object}  props       `this.props` for the parent component.\n * @param  {Object} state        `this.state` for the parent component.\n * @param  {Function} setState    Function that, when called, will `this.setState` on\n *                                 the parent component with the provided object.\n *\n * @return {Function}              Child-prop transformation function.\n */\nexport function getTransitionPropsFactory(props, state, setState) {\n  const nodesWillExit = state && state.nodesWillExit;\n  const nodesWillEnter = state && state.nodesWillEnter;\n  const nodesShouldEnter = state && state.nodesShouldEnter;\n  const nodesShouldLoad = state && state.nodesShouldLoad;\n  const nodesDoneLoad = state && state.nodesDoneLoad;\n  const childrenTransitions = state && state.childrenTransitions || [];\n  const transitionDurations = {\n    enter: props.animate && props.animate.onEnter && props.animate.onEnter.duration,\n    exit: props.animate && props.animate.onExit && props.animate.onExit.duration,\n    load: props.animate && props.animate.onLoad && props.animate.onLoad.duration,\n    move: props.animate && props.animate.duration\n  };\n  const onLoad = (child, data, animate) => {\n    if (nodesShouldLoad) {\n      return getChildOnLoad(animate, data, () => {\n        setState({\n          nodesShouldLoad: false,\n          nodesDoneLoad: true\n        });\n      });\n    }\n    return getChildBeforeLoad(animate, child, data, () => {\n      setState({\n        nodesDoneLoad: true\n      });\n    });\n  };\n\n  // eslint-disable-next-line max-params\n  const onExit = (nodes, child, data, animate) => {\n    return getChildPropsOnExit(animate, child, data, nodes, () => {\n      setState({\n        nodesWillExit: false\n      });\n    });\n  };\n\n  // eslint-disable-next-line max-params\n  const onEnter = (nodes, child, data, animate) => {\n    if (nodesShouldEnter) {\n      return getChildPropsOnEnter(animate, data, nodes, () => {\n        setState({\n          nodesWillEnter: false\n        });\n      });\n    }\n    return getChildPropsBeforeEnter(animate, child, data, nodes, () => {\n      setState({\n        nodesShouldEnter: true\n      });\n    });\n  };\n  const getChildTransitionDuration = function (child, type) {\n    const animate = child.props.animate;\n    if (!child.type) {\n      return {};\n    }\n    const defaultTransitions = child.props && child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n    if (defaultTransitions) {\n      const animationDuration = animate[type] && animate[type].duration;\n      return animationDuration !== undefined ? animationDuration : defaultTransitions[type] && defaultTransitions[type].duration;\n    }\n    return {};\n  };\n\n  // eslint-disable-next-line max-statements, complexity, max-len\n  return function getTransitionProps(child, index) {\n    const data = getChildData(child) || [];\n    const animate = _defaults({}, props.animate, child.props.animate);\n    const defaultTransitions = child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;\n    animate.onExit = _defaults({}, animate.onExit, defaultTransitions && defaultTransitions.onExit);\n    animate.onEnter = _defaults({}, animate.onEnter, defaultTransitions && defaultTransitions.onEnter);\n    animate.onLoad = _defaults({}, animate.onLoad, defaultTransitions && defaultTransitions.onLoad);\n    const childTransitions = childrenTransitions[index] || childrenTransitions[0];\n    if (!nodesDoneLoad) {\n      // should do onLoad animation\n      const load = transitionDurations.load !== undefined ? transitionDurations.load : getChildTransitionDuration(child, \"onLoad\");\n      const animation = {\n        duration: load\n      };\n      return onLoad(child, data, Object.assign({}, animate, animation));\n    } else if (nodesWillExit) {\n      const exitingNodes = childTransitions && childTransitions.exiting;\n      const exit = transitionDurations.exit !== undefined ? transitionDurations.exit : getChildTransitionDuration(child, \"onExit\");\n      // if nodesWillExit, but this child has no exiting nodes, set a delay instead of a duration\n      const animation = exitingNodes ? {\n        duration: exit\n      } : {\n        delay: exit\n      };\n      return onExit(exitingNodes, child, data, Object.assign({}, animate, animation));\n    } else if (nodesWillEnter) {\n      const enteringNodes = childTransitions && childTransitions.entering;\n      const enter = transitionDurations.enter !== undefined ? transitionDurations.enter : getChildTransitionDuration(child, \"onEnter\");\n      const move = transitionDurations.move !== undefined ? transitionDurations.move : child.props.animate && child.props.animate.duration;\n      const animation = {\n        duration: nodesShouldEnter && enteringNodes ? enter : move\n      };\n      return onEnter(enteringNodes, child, data, Object.assign({}, animate, animation));\n    } else if (!state && animate && animate.onExit) {\n      // This is the initial render, and nodes may enter when props change. Because\n      // animation interpolation is determined by old- and next- props, data may need\n      // to be augmented with certain properties.\n      //\n      // For example, it may be desired that exiting nodes go from `opacity: 1` to\n      // `opacity: 0`. Without setting this on a per-datum basis, the interpolation\n      // might go from `opacity: undefined` to `opacity: 0`, which would result in\n      // interpolated `opacity: NaN` values.\n      //\n      return getInitialChildProps(animate, data);\n    }\n    return {\n      animate,\n      data\n    };\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
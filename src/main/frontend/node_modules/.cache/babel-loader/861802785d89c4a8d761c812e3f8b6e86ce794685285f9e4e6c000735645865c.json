{"ast":null,"code":"import _defineProperty from \"C:/Users/\\uC190\\uD55C\\uC2B9/Desktop/project-subway/src/main/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"C:/Users/\\uC190\\uD55C\\uC2B9/Desktop/project-subway/src/main/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _uniq from \"lodash/uniq\";\nimport _omitBy from \"lodash/omitBy\";\nimport _pickBy from \"lodash/pickBy\";\nimport _isEmpty from \"lodash/isEmpty\";\n/* eslint-disable no-use-before-define */\nimport { isFunction } from \"./helpers\";\nvar GLOBAL_EVENT_REGEX = /^onGlobal(.*)$/;\n\n// Normally we'd use Template Literal Types, but we're avoiding it to maximize TS compatibility with TS < 4.1\n// `on${Capitalize<string>}`;\n\n/* Returns all own and shared events that should be attached to a single target element,\n * i.e. an individual bar specified by target: \"data\", eventKey: [index].\n * Returned events are scoped to the appropriate state. Either that of the component itself\n * (i.e. VictoryBar) in the case of own events, or that of the parent component\n * (i.e. VictoryChart) in the case of shared events\n */\n// eslint-disable-next-line max-params\nexport function getEvents(props, target, eventKey,\n// eslint-disable-next-line no-shadow\ngetScopedEvents) {\n  var _this = this;\n  // Returns all events that apply to a particular target element\n  var getEventsByTarget = function getEventsByTarget(events) {\n    var getSelectedEvents = function getSelectedEvents() {\n      var targetEvents = events.reduce(function (memo, event) {\n        if (event.target !== undefined) {\n          var matchesTarget = Array.isArray(event.target) ? event.target.includes(target) : \"\".concat(event.target) === \"\".concat(target);\n          return matchesTarget ? memo.concat(event) : memo;\n        }\n        return memo.concat(event);\n      }, []);\n      if (eventKey !== undefined && target !== \"parent\") {\n        return targetEvents.filter(function (obj) {\n          var targetKeys = obj.eventKey;\n          var useKey = function useKey(key) {\n            return key ? \"\".concat(key) === \"\".concat(eventKey) : true;\n          };\n          return Array.isArray(targetKeys) ? targetKeys.some(function (k) {\n            return useKey(k);\n          }) : useKey(targetKeys);\n        });\n      }\n      return targetEvents;\n    };\n    var selectedEvents = getSelectedEvents();\n    return Array.isArray(selectedEvents) && selectedEvents.reduce(function (memo, event) {\n      return event ? Object.assign(memo, event.eventHandlers) : memo;\n    }, {});\n  };\n\n  /* Returns all events from props and defaultEvents from components. Events handlers\n   * specified in props will override handlers for the same event if they are also\n   * specified in defaultEvents of a sub-component\n   */\n  var getAllEvents = function getAllEvents() {\n    // Mandatory usage: `getEvents.bind(this)`\n    /* eslint-disable no-invalid-this */\n    if (Array.isArray(_this.componentEvents)) {\n      var _this$componentEvents;\n      return Array.isArray(props.events) ? (_this$componentEvents = _this.componentEvents).concat.apply(_this$componentEvents, _toConsumableArray(props.events)) : _this.componentEvents;\n    }\n    /* eslint-enable no-invalid-this */\n    return props.events;\n  };\n  var allEvents = getAllEvents();\n  var ownEvents = allEvents && isFunction(getScopedEvents) ? getScopedEvents(getEventsByTarget(allEvents), target) : undefined;\n  if (!props.sharedEvents) {\n    return ownEvents;\n  }\n  var getSharedEvents = props.sharedEvents.getEvents;\n  var sharedEvents = props.sharedEvents.events && getSharedEvents(getEventsByTarget(props.sharedEvents.events), target);\n  return Object.assign({}, sharedEvents, ownEvents);\n}\n\n/* Returns a modified events object where each event handler is replaced by a new\n * function that calls the original handler and then calls setState with the return\n * of the original event handler assigned to state property that maps to the target\n * element.\n */\n// eslint-disable-next-line max-params\nexport function getScopedEvents(events, namespace, childType, baseProps) {\n  var _this2 = this;\n  if (_isEmpty(events)) {\n    return {};\n  }\n\n  // Mandatory usage: `getScopedEvents.bind(this)`\n  // eslint-disable-next-line no-invalid-this\n  var newBaseProps = baseProps || this.baseProps;\n  // returns the original base props or base state of a given target element\n  var getTargetProps = function getTargetProps(identifier, type) {\n    var childName = identifier.childName,\n      target = identifier.target,\n      key = identifier.key;\n    // eslint-disable-next-line no-invalid-this\n    var baseType = type === \"props\" ? newBaseProps : _this2.state || {};\n    var base = childName === undefined || childName === null || !baseType[childName] ? baseType : baseType[childName];\n    return key === \"parent\" ? base.parent : base[key] && base[key][target];\n  };\n\n  // Returns the state object with the mutation caused by a given eventReturn\n  // applied to the appropriate property on the state object\n  var parseEvent = function parseEvent(eventReturn, eventKey) {\n    var childNames = namespace === \"parent\" ? eventReturn.childName : eventReturn.childName || childType;\n    var target = eventReturn.target || namespace;\n\n    // returns all eventKeys to modify for a targeted childName\n    var getKeys = function getKeys(childName) {\n      if (target === \"parent\") {\n        return \"parent\";\n      }\n      if (eventReturn.eventKey === \"all\") {\n        return newBaseProps[childName] ? Object.keys(newBaseProps[childName]).filter(function (value) {\n          return value !== \"parent\";\n        }) : Object.keys(newBaseProps).filter(function (value) {\n          return value !== \"parent\";\n        });\n      } else if (eventReturn.eventKey === undefined && eventKey === \"parent\") {\n        return newBaseProps[childName] ? Object.keys(newBaseProps[childName]) : Object.keys(newBaseProps);\n      }\n      return eventReturn.eventKey !== undefined ? eventReturn.eventKey : eventKey;\n    };\n\n    // returns the state object with mutated props applied for a single key\n    var getMutationObject = function getMutationObject(key, childName) {\n      // eslint-disable-next-line no-invalid-this\n      var baseState = _this2.state || {};\n      if (!isFunction(eventReturn.mutation)) {\n        return baseState;\n      }\n      var mutationTargetProps = getTargetProps({\n        childName: childName,\n        key: key,\n        target: target\n      }, \"props\");\n      var mutationTargetState = getTargetProps({\n        childName: childName,\n        key: key,\n        target: target\n      }, \"state\");\n      var mutatedProps = eventReturn.mutation(Object.assign({}, mutationTargetProps, mutationTargetState), newBaseProps);\n      var childState = baseState[childName] || {};\n      var filterState = function filterState(state) {\n        if (state[key] && state[key][target]) {\n          delete state[key][target];\n        }\n        if (state[key] && !Object.keys(state[key]).length) {\n          delete state[key];\n        }\n        return state;\n      };\n      var extendState = function extendState(state) {\n        return target === \"parent\" ? Object.assign(state, _defineProperty({}, key, Object.assign(state[key] || {}, mutatedProps))) : Object.assign(state, _defineProperty({}, key, Object.assign(state[key] || {}, _defineProperty({}, target, mutatedProps))));\n      };\n      var updateState = function updateState(state) {\n        return mutatedProps ? extendState(state) : filterState(state);\n      };\n      return childName !== undefined && childName !== null ? Object.assign(baseState, _defineProperty({}, childName, updateState(childState))) : updateState(baseState);\n    };\n\n    // returns entire mutated state for a given childName\n    var getReturnByChild = function getReturnByChild(childName) {\n      var mutationKeys = getKeys(childName);\n      return Array.isArray(mutationKeys) ? mutationKeys.reduce(function (memo, key) {\n        return Object.assign(memo, getMutationObject(key, childName));\n      }, {}) : getMutationObject(mutationKeys, childName);\n    };\n\n    // returns an entire mutated state for all children\n    var allChildNames = childNames === \"all\" ? Object.keys(newBaseProps).filter(function (value) {\n      return value !== \"parent\";\n    }) : childNames;\n    return Array.isArray(allChildNames) ? allChildNames.reduce(function (memo, childName) {\n      return Object.assign(memo, getReturnByChild(childName));\n    }, {}) : getReturnByChild(allChildNames);\n  };\n\n  // Parses an array of event returns into a single state mutation\n  var parseEventReturn = function parseEventReturn(eventReturn, eventKey) {\n    return Array.isArray(eventReturn) ? eventReturn.reduce(function (memo, props) {\n      return Object.assign({}, memo, parseEvent(props, eventKey));\n    }, {}) : parseEvent(eventReturn, eventKey);\n  };\n  var compileCallbacks = function compileCallbacks(eventReturn) {\n    var getCallback = function getCallback(obj) {\n      return isFunction(obj.callback) && obj.callback;\n    };\n    var callbacks = Array.isArray(eventReturn) ? eventReturn.map(function (evtObj) {\n      return getCallback(evtObj);\n    }) : [getCallback(eventReturn)];\n    var callbackArray = callbacks.filter(function (callback) {\n      return callback !== false;\n    });\n    return callbackArray.length ? function () {\n      return callbackArray.forEach(function (callback) {\n        return callback();\n      });\n    } : undefined;\n  };\n\n  // A function that calls a particular event handler, parses its return\n  // into a state mutation, and calls setState\n  // eslint-disable-next-line max-params\n  var onEvent = function onEvent(evt, childProps, eventKey, eventName) {\n    // eslint-disable-next-line no-invalid-this\n    var eventReturn = events[eventName](evt, childProps, eventKey, _this2);\n    if (!_isEmpty(eventReturn)) {\n      var callbacks = compileCallbacks(eventReturn);\n      // eslint-disable-next-line no-invalid-this\n      _this2.setState(parseEventReturn(eventReturn, eventKey), callbacks);\n    }\n  };\n\n  // returns a new events object with enhanced event handlers\n  return Object.keys(events).reduce(function (memo, event) {\n    memo[event] = onEvent;\n    return memo;\n  }, {});\n}\n\n/*\n * Returns a partially applied event handler for a specific target element\n * This allows event handlers to have access to props controlling each element\n */\nexport function getPartialEvents(events, eventKey, childProps) {\n  if (!events) return {};\n  return Object.keys(events).reduce(function (memo, eventName) {\n    var appliedEvent = function appliedEvent(evt) {\n      return events[eventName](evt, childProps, eventKey, eventName);\n    };\n    memo[eventName] = appliedEvent;\n    return memo;\n  }, {});\n}\n/* Returns the property of the state object corresponding to event changes for\n * a particular element\n */\n// eslint-disable-next-line max-params\nexport function getEventState(eventKey, namespace, childType) {\n  // Mandatory usage: `getEventState.bind(this)`\n  // eslint-disable-next-line no-invalid-this\n  var state = this.state || {};\n  if (!childType) {\n    return eventKey === \"parent\" ? state[eventKey] && state[eventKey][namespace] || state[eventKey] : state[eventKey] && state[eventKey][namespace];\n  }\n  return state[childType] && state[childType][eventKey] && state[childType][eventKey][namespace];\n}\n\n/**\n * Returns a set of all mutations for shared events\n *\n * @param  {Array} mutations an array of mutations objects\n * @param  {Object} baseProps an object that describes all props for children of VictorySharedEvents\n * @param  {Object} baseState an object that describes state for children of VictorySharedEvents\n * @param  {Array} childNames an array of childNames\n *\n * @return {Object} a object describing all mutations for VictorySharedEvents\n */\n// eslint-disable-next-line max-params\nexport function getExternalMutationsWithChildren(mutations, baseProps, baseState, childNames) {\n  if (baseProps === void 0) {\n    baseProps = {};\n  }\n  if (baseState === void 0) {\n    baseState = {};\n  }\n  return childNames.reduce(function (memo, childName) {\n    var childState = baseState[childName];\n    var mutation = getExternalMutations(mutations, baseProps[childName], baseState[childName], childName);\n    memo[childName] = mutation ? mutation : childState;\n    return _pickBy(memo, function (v) {\n      return !_isEmpty(v);\n    });\n  }, {});\n}\n\n/**\n * Returns a set of all mutations for a component\n *\n * @param  {Array} mutations an array of mutations objects\n * @param  {Object} baseProps a props object (scoped to a childName when used by shared events)\n * @param  {Object} baseState a state object (scoped to a childName when used by shared events)\n * @param  {String} childName an optional childName\n *\n * @return {Object} a object describing mutations for a given component\n */\n// eslint-disable-next-line max-params\nexport function getExternalMutations(mutations, baseProps, baseState, childName) {\n  if (baseProps === void 0) {\n    baseProps = {};\n  }\n  if (baseState === void 0) {\n    baseState = {};\n  }\n  var eventKeys = Object.keys(baseProps);\n  return eventKeys.reduce(function (memo, eventKey) {\n    var keyState = baseState[eventKey] || {};\n    var keyProps = baseProps[eventKey] || {};\n    if (eventKey === \"parent\") {\n      var identifier = {\n        eventKey: eventKey,\n        target: \"parent\"\n      };\n      var mutation = getExternalMutation(mutations, keyProps, keyState, identifier);\n      memo[eventKey] = mutation !== undefined ? Object.assign({}, keyState, mutation) : keyState;\n    } else {\n      // use keys from both state and props so that elements not intially included in baseProps\n      // will be used. (i.e. labels)\n      var targets = _uniq(Object.keys(keyProps).concat(Object.keys(keyState)));\n      memo[eventKey] = targets.reduce(function (m, target) {\n        var identifier = {\n          eventKey: eventKey,\n          target: target,\n          childName: childName\n        };\n        var mutation = getExternalMutation(mutations, keyProps[target], keyState[target], identifier);\n        m[target] = mutation !== undefined ? Object.assign({}, keyState[target], mutation) : keyState[target];\n        return _pickBy(m, function (v) {\n          return !_isEmpty(v);\n        });\n      }, {});\n    }\n    return _pickBy(memo, function (v) {\n      return !_isEmpty(v);\n    });\n  }, {});\n}\n\n/**\n * Returns a set of mutations for a particular element given scoped baseProps and baseState\n *\n * @param  {Array} mutations an array of mutations objects\n * @param  {Object} baseProps a props object (scoped the element specified by the identifier)\n * @param  {Object} baseState a state object (scoped the element specified by the identifier)\n * @param  {Object} identifier { eventKey, target, childName }\n *\n * @return {Object | undefined} a object describing mutations for a given element, or undefined\n */\n// eslint-disable-next-line max-params\nexport function getExternalMutation(mutations, baseProps, baseState, identifier) {\n  var filterMutations = function filterMutations(mutation, type) {\n    if (typeof mutation[type] === \"string\") {\n      return mutation[type] === \"all\" || mutation[type] === identifier[type];\n    } else if (Array.isArray(mutation[type])) {\n      // coerce arrays to strings before matching\n      var stringArray = mutation[type].map(function (m) {\n        return \"\".concat(m);\n      });\n      return stringArray.includes(identifier[type]);\n    }\n    return false;\n  };\n  var scopedMutations = Array.isArray(mutations) ? mutations : [mutations];\n  if (identifier.childName) {\n    scopedMutations = mutations.filter(function (m) {\n      return filterMutations(m, \"childName\");\n    });\n  }\n  // find any mutation objects that match the target\n  var targetMutations = scopedMutations.filter(function (m) {\n    return filterMutations(m, \"target\");\n  });\n  if (_isEmpty(targetMutations)) {\n    return undefined;\n  }\n  var keyMutations = targetMutations.filter(function (m) {\n    return filterMutations(m, \"eventKey\");\n  });\n  if (_isEmpty(keyMutations)) {\n    return undefined;\n  }\n  return keyMutations.reduce(function (memo, curr) {\n    var mutationFunction = curr && isFunction(curr.mutation) ? curr.mutation : function () {\n      return undefined;\n    };\n    var currentMutation = mutationFunction(Object.assign({}, baseProps, baseState));\n    return Object.assign({}, memo, currentMutation);\n  }, {});\n}\n\n/* Returns an array of defaultEvents from sub-components of a given component.\n * i.e. any static `defaultEvents` on `labelComponent` will be returned\n */\nexport function getComponentEvents(props, components) {\n  var events = Array.isArray(components) && components.reduce(function (memo, componentName) {\n    var component = props[componentName];\n    var defaultEvents = component && component.type && component.type.defaultEvents;\n    var componentEvents = isFunction(defaultEvents) ? defaultEvents(component.props) : defaultEvents;\n    return Array.isArray(componentEvents) ? memo.concat.apply(memo, _toConsumableArray(componentEvents)) : memo;\n  }, []);\n  return events && events.length ? events : undefined;\n}\nexport function getGlobalEventNameFromKey(key) {\n  var match = key.match(GLOBAL_EVENT_REGEX);\n  return match && match[1] && match[1].toLowerCase();\n}\nexport var getGlobalEvents = function getGlobalEvents(events) {\n  return _pickBy(events, function (_, key) {\n    return GLOBAL_EVENT_REGEX.test(key);\n  });\n};\nexport var omitGlobalEvents = function omitGlobalEvents(events) {\n  return _omitBy(events, function (_, key) {\n    return GLOBAL_EVENT_REGEX.test(key);\n  });\n};\nexport var emulateReactEvent = function emulateReactEvent(event) {\n  return Object.assign(event, {\n    nativeEvent: event\n  });\n};","map":{"version":3,"names":["_uniq","_omitBy","_pickBy","_isEmpty","isFunction","GLOBAL_EVENT_REGEX","getEvents","props","target","eventKey","getScopedEvents","_this","getEventsByTarget","events","getSelectedEvents","targetEvents","reduce","memo","event","undefined","matchesTarget","Array","isArray","includes","concat","filter","obj","targetKeys","useKey","key","some","k","selectedEvents","Object","assign","eventHandlers","getAllEvents","componentEvents","_this$componentEvents","apply","_toConsumableArray","allEvents","ownEvents","sharedEvents","getSharedEvents","namespace","childType","baseProps","_this2","newBaseProps","getTargetProps","identifier","type","childName","baseType","state","base","parent","parseEvent","eventReturn","childNames","getKeys","keys","value","getMutationObject","baseState","mutation","mutationTargetProps","mutationTargetState","mutatedProps","childState","filterState","length","extendState","_defineProperty","updateState","getReturnByChild","mutationKeys","allChildNames","parseEventReturn","compileCallbacks","getCallback","callback","callbacks","map","evtObj","callbackArray","forEach","onEvent","evt","childProps","eventName","setState","getPartialEvents","appliedEvent","getEventState","getExternalMutationsWithChildren","mutations","getExternalMutations","v","eventKeys","keyState","keyProps","getExternalMutation","targets","m","filterMutations","stringArray","scopedMutations","targetMutations","keyMutations","curr","mutationFunction","currentMutation","getComponentEvents","components","componentName","component","defaultEvents","getGlobalEventNameFromKey","match","toLowerCase","getGlobalEvents","_","test","omitGlobalEvents","emulateReactEvent","nativeEvent"],"sources":["C:/Users/손한승/Desktop/project-subway/src/main/frontend/node_modules/victory-core/es/victory-util/events.js"],"sourcesContent":["import _uniq from \"lodash/uniq\";\nimport _omitBy from \"lodash/omitBy\";\nimport _pickBy from \"lodash/pickBy\";\nimport _isEmpty from \"lodash/isEmpty\";\n/* eslint-disable no-use-before-define */\nimport { isFunction } from \"./helpers\";\nconst GLOBAL_EVENT_REGEX = /^onGlobal(.*)$/;\n\n// Normally we'd use Template Literal Types, but we're avoiding it to maximize TS compatibility with TS < 4.1\n// `on${Capitalize<string>}`;\n\n/* Returns all own and shared events that should be attached to a single target element,\n * i.e. an individual bar specified by target: \"data\", eventKey: [index].\n * Returned events are scoped to the appropriate state. Either that of the component itself\n * (i.e. VictoryBar) in the case of own events, or that of the parent component\n * (i.e. VictoryChart) in the case of shared events\n */\n// eslint-disable-next-line max-params\nexport function getEvents(props, target, eventKey,\n// eslint-disable-next-line no-shadow\ngetScopedEvents) {\n  // Returns all events that apply to a particular target element\n  const getEventsByTarget = events => {\n    const getSelectedEvents = () => {\n      const targetEvents = events.reduce((memo, event) => {\n        if (event.target !== undefined) {\n          const matchesTarget = Array.isArray(event.target) ? event.target.includes(target) : `${event.target}` === `${target}`;\n          return matchesTarget ? memo.concat(event) : memo;\n        }\n        return memo.concat(event);\n      }, []);\n      if (eventKey !== undefined && target !== \"parent\") {\n        return targetEvents.filter(obj => {\n          const targetKeys = obj.eventKey;\n          const useKey = key => key ? `${key}` === `${eventKey}` : true;\n          return Array.isArray(targetKeys) ? targetKeys.some(k => useKey(k)) : useKey(targetKeys);\n        });\n      }\n      return targetEvents;\n    };\n    const selectedEvents = getSelectedEvents();\n    return Array.isArray(selectedEvents) && selectedEvents.reduce((memo, event) => {\n      return event ? Object.assign(memo, event.eventHandlers) : memo;\n    }, {});\n  };\n\n  /* Returns all events from props and defaultEvents from components. Events handlers\n   * specified in props will override handlers for the same event if they are also\n   * specified in defaultEvents of a sub-component\n   */\n  const getAllEvents = () => {\n    // Mandatory usage: `getEvents.bind(this)`\n    /* eslint-disable no-invalid-this */\n    if (Array.isArray(this.componentEvents)) {\n      return Array.isArray(props.events) ? this.componentEvents.concat(...props.events) : this.componentEvents;\n    }\n    /* eslint-enable no-invalid-this */\n    return props.events;\n  };\n  const allEvents = getAllEvents();\n  const ownEvents = allEvents && isFunction(getScopedEvents) ? getScopedEvents(getEventsByTarget(allEvents), target) : undefined;\n  if (!props.sharedEvents) {\n    return ownEvents;\n  }\n  const getSharedEvents = props.sharedEvents.getEvents;\n  const sharedEvents = props.sharedEvents.events && getSharedEvents(getEventsByTarget(props.sharedEvents.events), target);\n  return Object.assign({}, sharedEvents, ownEvents);\n}\n\n/* Returns a modified events object where each event handler is replaced by a new\n * function that calls the original handler and then calls setState with the return\n * of the original event handler assigned to state property that maps to the target\n * element.\n */\n// eslint-disable-next-line max-params\nexport function getScopedEvents(events, namespace, childType, baseProps) {\n  if (_isEmpty(events)) {\n    return {};\n  }\n\n  // Mandatory usage: `getScopedEvents.bind(this)`\n  // eslint-disable-next-line no-invalid-this\n  const newBaseProps = baseProps || this.baseProps;\n  // returns the original base props or base state of a given target element\n  const getTargetProps = (identifier, type) => {\n    const {\n      childName,\n      target,\n      key\n    } = identifier;\n    // eslint-disable-next-line no-invalid-this\n    const baseType = type === \"props\" ? newBaseProps : this.state || {};\n    const base = childName === undefined || childName === null || !baseType[childName] ? baseType : baseType[childName];\n    return key === \"parent\" ? base.parent : base[key] && base[key][target];\n  };\n\n  // Returns the state object with the mutation caused by a given eventReturn\n  // applied to the appropriate property on the state object\n  const parseEvent = (eventReturn, eventKey) => {\n    const childNames = namespace === \"parent\" ? eventReturn.childName : eventReturn.childName || childType;\n    const target = eventReturn.target || namespace;\n\n    // returns all eventKeys to modify for a targeted childName\n    const getKeys = childName => {\n      if (target === \"parent\") {\n        return \"parent\";\n      }\n      if (eventReturn.eventKey === \"all\") {\n        return newBaseProps[childName] ? Object.keys(newBaseProps[childName]).filter(value => value !== \"parent\") : Object.keys(newBaseProps).filter(value => value !== \"parent\");\n      } else if (eventReturn.eventKey === undefined && eventKey === \"parent\") {\n        return newBaseProps[childName] ? Object.keys(newBaseProps[childName]) : Object.keys(newBaseProps);\n      }\n      return eventReturn.eventKey !== undefined ? eventReturn.eventKey : eventKey;\n    };\n\n    // returns the state object with mutated props applied for a single key\n    const getMutationObject = (key, childName) => {\n      // eslint-disable-next-line no-invalid-this\n      const baseState = this.state || {};\n      if (!isFunction(eventReturn.mutation)) {\n        return baseState;\n      }\n      const mutationTargetProps = getTargetProps({\n        childName,\n        key,\n        target\n      }, \"props\");\n      const mutationTargetState = getTargetProps({\n        childName,\n        key,\n        target\n      }, \"state\");\n      const mutatedProps = eventReturn.mutation(Object.assign({}, mutationTargetProps, mutationTargetState), newBaseProps);\n      const childState = baseState[childName] || {};\n      const filterState = state => {\n        if (state[key] && state[key][target]) {\n          delete state[key][target];\n        }\n        if (state[key] && !Object.keys(state[key]).length) {\n          delete state[key];\n        }\n        return state;\n      };\n      const extendState = state => {\n        return target === \"parent\" ? Object.assign(state, {\n          [key]: Object.assign(state[key] || {}, mutatedProps)\n        }) : Object.assign(state, {\n          [key]: Object.assign(state[key] || {}, {\n            [target]: mutatedProps\n          })\n        });\n      };\n      const updateState = state => {\n        return mutatedProps ? extendState(state) : filterState(state);\n      };\n      return childName !== undefined && childName !== null ? Object.assign(baseState, {\n        [childName]: updateState(childState)\n      }) : updateState(baseState);\n    };\n\n    // returns entire mutated state for a given childName\n    const getReturnByChild = childName => {\n      const mutationKeys = getKeys(childName);\n      return Array.isArray(mutationKeys) ? mutationKeys.reduce((memo, key) => {\n        return Object.assign(memo, getMutationObject(key, childName));\n      }, {}) : getMutationObject(mutationKeys, childName);\n    };\n\n    // returns an entire mutated state for all children\n    const allChildNames = childNames === \"all\" ? Object.keys(newBaseProps).filter(value => value !== \"parent\") : childNames;\n    return Array.isArray(allChildNames) ? allChildNames.reduce((memo, childName) => {\n      return Object.assign(memo, getReturnByChild(childName));\n    }, {}) : getReturnByChild(allChildNames);\n  };\n\n  // Parses an array of event returns into a single state mutation\n  const parseEventReturn = (eventReturn, eventKey) => {\n    return Array.isArray(eventReturn) ? eventReturn.reduce((memo, props) => Object.assign({}, memo, parseEvent(props, eventKey)), {}) : parseEvent(eventReturn, eventKey);\n  };\n  const compileCallbacks = eventReturn => {\n    const getCallback = obj => isFunction(obj.callback) && obj.callback;\n    const callbacks = Array.isArray(eventReturn) ? eventReturn.map(evtObj => getCallback(evtObj)) : [getCallback(eventReturn)];\n    const callbackArray = callbacks.filter(callback => callback !== false);\n    return callbackArray.length ? () => callbackArray.forEach(callback => callback()) : undefined;\n  };\n\n  // A function that calls a particular event handler, parses its return\n  // into a state mutation, and calls setState\n  // eslint-disable-next-line max-params\n  const onEvent = (evt, childProps, eventKey, eventName) => {\n    // eslint-disable-next-line no-invalid-this\n    const eventReturn = events[eventName](evt, childProps, eventKey, this);\n    if (!_isEmpty(eventReturn)) {\n      const callbacks = compileCallbacks(eventReturn);\n      // eslint-disable-next-line no-invalid-this\n      this.setState(parseEventReturn(eventReturn, eventKey), callbacks);\n    }\n  };\n\n  // returns a new events object with enhanced event handlers\n  return Object.keys(events).reduce((memo, event) => {\n    memo[event] = onEvent;\n    return memo;\n  }, {});\n}\n\n/*\n * Returns a partially applied event handler for a specific target element\n * This allows event handlers to have access to props controlling each element\n */\nexport function getPartialEvents(events, eventKey, childProps) {\n  if (!events) return {};\n  return Object.keys(events).reduce((memo, eventName) => {\n    const appliedEvent = evt => events[eventName](evt, childProps, eventKey, eventName);\n    memo[eventName] = appliedEvent;\n    return memo;\n  }, {});\n}\n/* Returns the property of the state object corresponding to event changes for\n * a particular element\n */\n// eslint-disable-next-line max-params\nexport function getEventState(eventKey, namespace, childType) {\n  // Mandatory usage: `getEventState.bind(this)`\n  // eslint-disable-next-line no-invalid-this\n  const state = this.state || {};\n  if (!childType) {\n    return eventKey === \"parent\" ? state[eventKey] && state[eventKey][namespace] || state[eventKey] : state[eventKey] && state[eventKey][namespace];\n  }\n  return state[childType] && state[childType][eventKey] && state[childType][eventKey][namespace];\n}\n\n/**\n * Returns a set of all mutations for shared events\n *\n * @param  {Array} mutations an array of mutations objects\n * @param  {Object} baseProps an object that describes all props for children of VictorySharedEvents\n * @param  {Object} baseState an object that describes state for children of VictorySharedEvents\n * @param  {Array} childNames an array of childNames\n *\n * @return {Object} a object describing all mutations for VictorySharedEvents\n */\n// eslint-disable-next-line max-params\nexport function getExternalMutationsWithChildren(mutations, baseProps, baseState, childNames) {\n  if (baseProps === void 0) {\n    baseProps = {};\n  }\n  if (baseState === void 0) {\n    baseState = {};\n  }\n  return childNames.reduce((memo, childName) => {\n    const childState = baseState[childName];\n    const mutation = getExternalMutations(mutations, baseProps[childName], baseState[childName], childName);\n    memo[childName] = mutation ? mutation : childState;\n    return _pickBy(memo, v => !_isEmpty(v));\n  }, {});\n}\n\n/**\n * Returns a set of all mutations for a component\n *\n * @param  {Array} mutations an array of mutations objects\n * @param  {Object} baseProps a props object (scoped to a childName when used by shared events)\n * @param  {Object} baseState a state object (scoped to a childName when used by shared events)\n * @param  {String} childName an optional childName\n *\n * @return {Object} a object describing mutations for a given component\n */\n// eslint-disable-next-line max-params\nexport function getExternalMutations(mutations, baseProps, baseState, childName) {\n  if (baseProps === void 0) {\n    baseProps = {};\n  }\n  if (baseState === void 0) {\n    baseState = {};\n  }\n  const eventKeys = Object.keys(baseProps);\n  return eventKeys.reduce((memo, eventKey) => {\n    const keyState = baseState[eventKey] || {};\n    const keyProps = baseProps[eventKey] || {};\n    if (eventKey === \"parent\") {\n      const identifier = {\n        eventKey,\n        target: \"parent\"\n      };\n      const mutation = getExternalMutation(mutations, keyProps, keyState, identifier);\n      memo[eventKey] = mutation !== undefined ? Object.assign({}, keyState, mutation) : keyState;\n    } else {\n      // use keys from both state and props so that elements not intially included in baseProps\n      // will be used. (i.e. labels)\n      const targets = _uniq(Object.keys(keyProps).concat(Object.keys(keyState)));\n      memo[eventKey] = targets.reduce((m, target) => {\n        const identifier = {\n          eventKey,\n          target,\n          childName\n        };\n        const mutation = getExternalMutation(mutations, keyProps[target], keyState[target], identifier);\n        m[target] = mutation !== undefined ? Object.assign({}, keyState[target], mutation) : keyState[target];\n        return _pickBy(m, v => !_isEmpty(v));\n      }, {});\n    }\n    return _pickBy(memo, v => !_isEmpty(v));\n  }, {});\n}\n\n/**\n * Returns a set of mutations for a particular element given scoped baseProps and baseState\n *\n * @param  {Array} mutations an array of mutations objects\n * @param  {Object} baseProps a props object (scoped the element specified by the identifier)\n * @param  {Object} baseState a state object (scoped the element specified by the identifier)\n * @param  {Object} identifier { eventKey, target, childName }\n *\n * @return {Object | undefined} a object describing mutations for a given element, or undefined\n */\n// eslint-disable-next-line max-params\nexport function getExternalMutation(mutations, baseProps, baseState, identifier) {\n  const filterMutations = (mutation, type) => {\n    if (typeof mutation[type] === \"string\") {\n      return mutation[type] === \"all\" || mutation[type] === identifier[type];\n    } else if (Array.isArray(mutation[type])) {\n      // coerce arrays to strings before matching\n      const stringArray = mutation[type].map(m => `${m}`);\n      return stringArray.includes(identifier[type]);\n    }\n    return false;\n  };\n  let scopedMutations = Array.isArray(mutations) ? mutations : [mutations];\n  if (identifier.childName) {\n    scopedMutations = mutations.filter(m => filterMutations(m, \"childName\"));\n  }\n  // find any mutation objects that match the target\n  const targetMutations = scopedMutations.filter(m => filterMutations(m, \"target\"));\n  if (_isEmpty(targetMutations)) {\n    return undefined;\n  }\n  const keyMutations = targetMutations.filter(m => filterMutations(m, \"eventKey\"));\n  if (_isEmpty(keyMutations)) {\n    return undefined;\n  }\n  return keyMutations.reduce((memo, curr) => {\n    const mutationFunction = curr && isFunction(curr.mutation) ? curr.mutation : () => undefined;\n    const currentMutation = mutationFunction(Object.assign({}, baseProps, baseState));\n    return Object.assign({}, memo, currentMutation);\n  }, {});\n}\n\n/* Returns an array of defaultEvents from sub-components of a given component.\n * i.e. any static `defaultEvents` on `labelComponent` will be returned\n */\nexport function getComponentEvents(props, components) {\n  const events = Array.isArray(components) && components.reduce((memo, componentName) => {\n    const component = props[componentName];\n    const defaultEvents = component && component.type && component.type.defaultEvents;\n    const componentEvents = isFunction(defaultEvents) ? defaultEvents(component.props) : defaultEvents;\n    return Array.isArray(componentEvents) ? memo.concat(...componentEvents) : memo;\n  }, []);\n  return events && events.length ? events : undefined;\n}\nexport function getGlobalEventNameFromKey(key) {\n  const match = key.match(GLOBAL_EVENT_REGEX);\n  return match && match[1] && match[1].toLowerCase();\n}\nexport const getGlobalEvents = events => _pickBy(events, (_, key) => GLOBAL_EVENT_REGEX.test(key));\nexport const omitGlobalEvents = events => _omitBy(events, (_, key) => GLOBAL_EVENT_REGEX.test(key));\nexport const emulateReactEvent = event => Object.assign(event, {\n  nativeEvent: event\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}